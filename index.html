<html lang="en">
	<head>
<!-- PWA metadata -->
<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#6750A4" />
<meta name="description" content="Wanxian: Biome Generator For Minecraft Bedrock Edition." />

<!-- Icons -->
<link rel="icon" href="icons/icon.svg" type="image/svg+xml" />

<!-- PNG fallbacks -->
<link rel="icon" href="icons/icon3.png" sizes="32x32" />
<link rel="icon" href="icons/icon2.png" sizes="192x192" />
<link rel="icon" href="icons/icon1.png" sizes="512x512" />

<!-- iOS -->
<link rel="apple-touch-icon" href="icons/icon-192.png" />
    <!-- iOS Support meta tags (Optional but recommended) -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, shrink-to-fit=no">
		<title>Wanxian - Biome Generator</title>
		<link href="/css2.css" rel="stylesheet">
		<link rel="stylesheet" href="styles.css">
		<script src="themes.js"></script> 
	</head>
	<body>
		<header class="expressive">
		    <div class="top-app-bar">
			<div class="leading-content">
				<div class="title">
					<h1>Wanxian</h1>
				</div>
			</div>
			</div>
			<style>

			</style>
			<div class="trailing-actions">
				<div class="more-options">
					<button class="m3-expressive-tonal-icon-button" id="more-button">
					<span class="material-symbols-rounded" style="font-variation-settings: 'FILL' 0, 'wght' 600, 'GRAD' 0, 'opsz' 24;"></span>
					</button>
					<div class="dropdown-menu" id="dropdown-menu">
						<a href="#" class="list-item" id="theme-toggle">
						<span class="material-symbols-rounded leading-icon">dark_mode</span>
						<span class="list-label">Dark Theme</span>
						<button class="icon-button trailing-icon-button" data-toggled="off">
						<span class="material-symbols-rounded">toggle_off</span>
						</button>
						</a>
						<div class="list-item" id="fullscreenBtn">
							<span class="material-symbols-rounded leading-icon"></span>
							<span class="list-label">Full Screen</span>
						</div>
						<!-- ADDED: Theme Button -->
<a href="#" class="list-item" id="theme-button">
    <span class="material-symbols-rounded leading-icon">palette</span>
    <span class="list-label">Change Theme</span>
</a>
<!-- END ADDED -->
<div class="menu-divider"></div>

						
						<a href="https://bsky.app/profile/niancookiepanda.bsky.social" class="list-item">
						<span class="material-symbols-rounded leading-icon">satellite_alt</span>
						<span class="list-label">BSKY Profile</span>
						</a>
						<div class="menu-divider"></div>
						<a href="#" class="list-item" id="about-button">
						<span class="material-symbols-rounded leading-icon">info</span>
						<span class="list-label">About Wanxian</span>
						</a>
					</div>
				</div>
			
		</header>
		<div class="about-dialog-backdrop" id="about-dialog-backdrop">
    <div class="about-dialog">
        <div class="dialog-header">
            <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary);">info</span>
            <h2>About Wanxian</h2>
        </div>
        
        <p>Wanxian is a simple and focused tool designed to help you create custom Minecraft Bedrock Edition biome JSON files with ease.</p>
        
        <p>It includes smart layout behavior, a smooth interface, and a system-aware dark theme to make editing more comfortable.</p>
        
        <p>The tool is built to keep everything clear and organized, offering quick access to biome parameters and real-time previews.</p>
        
        <hr style="border: none; border-top: 1px solid var(--md-sys-color-outline-variant); margin: 16px 0;">
        
        <p><strong>Feedback & More:</strong> If you notice issues or want to suggest improvements, you can share your thoughts directly at <a href="https://bsky.app/profile/niancookiepanda.bsky.social" style="color: var(--md-sys-color-primary);">Bluesky profile</a>.</p>
        
        <div class="dialog-actions">
            <button class="m3-text-button" id="close-about-button">Close</button>
        </div>
    </div>
</div>
		<div class="container">
			<!-- File and Form Management is no longer here-->
			<div class="tool-container" style="margin-top: 10px; margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 10px;">
				<input type="file" id="importJsonFile" accept=".json" style="display: none;">
				<button type="button" class="button add-button " id="importJsonButton">
				<span class="material-symbols-rounded">upload_file</span>
				Import JSON
				</button>
				<button type="button" class="button add-button" id="refreshButton">
				<span class="material-symbols-rounded">refresh</span>
				Reset Form
				</button>
			</div>
			<!-- Preset Management Section -->
			<form id="biomeForm">
				<!-- Core Biome Information -->
				<div class="form-group">
					<label for="format_version" class="required-field">Format Version:</label>
					<input type="text" id="format_version" value="1.21.120" required="">
					<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
						<span class="tooltiptext">Version of the JSON schema used by this file. Example: "1.21.120"</span>
					</div>
				</div>
				<div class="form-group">
					<label for="identifier" class="required-field">Biome Identifier:</label>
					<input type="text" id="identifier" placeholder="e.g., mypack:my_custom_biome" required="" value="wanxian:">
					<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
						<span class="tooltiptext">The namespaced name of your biome (e.g., "mypack:my_custom_biome"). Should only be lowercase and unique.</span>
					</div>
					<div id="validation" class="error" style="color: var(--md-sys-color-error); display:none; margin-top: 10px;"></div>
				</div>
				<h2>Biome Components</h2>
				<p>Select the components you wish to include in your biome definition.
				</p>
				<div class="switch-container">
					<label for="enable_clientbiomes">Client Biome:</label>
					<label class="switch">
					<input type="checkbox" id="enable_clientbiomes">
					<span class="slider"></span>
					</label>
				</div>
				<div class="menu-divider"></div>
				<!-- Group 1: Climate & Environmental Properties -->
				<h3>Climate &amp; Environmental Properties</h3>
				<!-- Component: minecraft:climate -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="climate-content">
						<span class="component-title">climate</span>
						<label class="switch">
						<input type="checkbox" id="enable_climate" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="climate-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Describes temperature, humidity, precipitation, and similar. Biomes without this component will have default values.</p>
							<div class="form-group">
								<label for="climate_temperature">Temperature (Float):</label>
								<input type="number" step="0.01" id="climate_temperature" placeholder="e.g., 0.3">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Temperature affects a variety of visual and behavioral things, including snow and ice placement, sponge drying, and sky color.</span>
								</div>
							</div>
							<div class="form-group">
								<label>Snow Accumulation (Min, Max - Array of 2 Floats):</label>
								<input type="number" step="0.001" id="climate_snow_acc_min" placeholder="e.g., 0.125">
								<input type="number" step="0.001" id="climate_snow_acc_max" placeholder="e.g., 0.25">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Minimum and maximum snow level, each multiple of 0.125 is another snow layer.</span>
								</div>
							</div>
							<div class="form-group">
								<label for="climate_downfall">Downfall (Float):</label>
								<input type="number" step="0.01" id="climate_downfall" placeholder="e.g., 0.2">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Amount that precipitation affects colors and block changes.</span>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:humidity -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="humidity-content">
						<span class="component-title">humidity</span>
						<label class="switch">
						<input type="checkbox" id="enable_humidity" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span> 
					</h3>
					<div id="humidity-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Forces a biome to either always be humid or never humid. Humidity affects the spread chance, and spread rate of fire in the biome.</p>
							<div class="switch-container">
								<label for="humidity_is_humid" class="required-field">Is Humid:</label>
								<label class="switch">
								<input type="checkbox" id="humidity_is_humid">
								<span class="slider"></span> 
								</label>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:partially_frozen -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="partially_frozen-content">
						<span class="component-title">partially frozen</span>
						<label class="switch">
						<input type="checkbox" id="enable_partially_frozen" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>  
					</h3>
					<div id="partially_frozen-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Component will impact the temperature in a frozen biome, causing some areas to not be frozen. Ex: patchy ice, patchy snow.</p>
							<p>This component has no configurable fields, just its presence matters.</p>
						</div>
					</div>
				</div>
				<!-- Group 3: Terrain Generation Rules -->
				<!-- Component: minecraft:multinoise_generation_rules no longer present here-->
				<!-- Group 4: Surface & Material Definitions -->
				<h3>Surface Material Definitions &amp; Terrain Generation Rules</h3>
				<!-- Component: minecraft:surface_builder -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="surface_builder-content">
						<span class="component-title">surface builder</span>
						<label class="switch">
						<input type="checkbox" id="enable_surface_builder" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="surface_builder-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Controls the materials used for terrain generation.</p>
							<div class="form-group">
								<label for="surface_builder_type_select" class="required-field">Builder Type:</label>
								<select id="surface_builder_type_select">
									<option value="">--Select Builder Type--</option>
									<option value="minecraft:overworld">minecraft:overworld</option>
									<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
									<option value="minecraft:mesa">minecraft:mesa</option>
									<option value="minecraft:swamp">minecraft:swamp</option>
									<option value="minecraft:capped">minecraft:capped</option>
									<option value="minecraft:the_end">minecraft:the_end</option>
								</select>
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Controls the type of surface builder to use.</span>
								</div>
							</div>
							<!-- Dynamic builder fields will be loaded here based on selection -->
							<div id="surface_builder_dynamic_fields"></div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:mountain_parameters -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="mountain_parameters-content">
						<span class="component-title">mountain parameters</span>
						<label class="switch">
						<input type="checkbox" id="enable_mountain_parameters" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="mountain_parameters-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Noise parameters used to drive mountain terrain generation in Overworld.</p>
							<h4>Top Slide Settings</h4>
							<div class="sub-group">
								<div class="switch-container">
									<label for="top_slide_enabled" class="required-field">Enabled:</label>
									<label class="switch">
									<input type="checkbox" id="top_slide_enabled">
									<span class="slider"></span>          </label>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">If false, top slide will be disabled. If true, other parameters will be taken into account.</span>
									</div>
								</div>
							</div>
							<div class="optional-input-container">
								<div class="switch-container">
									<label for="enable_steep_material_adjustment">Enable Steep Material Adjustment (Optional):</label>
									<label class="switch">
									<input type="checkbox" id="enable_steep_material_adjustment" class="optional-input-toggle">
									<span class="slider"></span>         </label>
								</div>
								<div id="steep_material_adjustment_group" class="optional-input-content" style="display: none;">
									<h4>Steep Material Adjustment Settings</h4>
									<div class="sub-group">
										<div class="form-group" id="steep_material_container">
											<div class="form-group">
												<label for="steep_material_name">Steep Material (Block Specifier):</label>
												<input type="text" id="steep_material_name" placeholder="e.g., minecraft:dirt" value="">
												<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
													<span class="tooltiptext">Name of the block. Example: "minecraft:stone"</span>
												</div>
											</div>
											<div class="optional-input-container">
												<div class="switch-container">
													<label for="toggle_steep_material_states">Enable States (Optional):</label>
													<label class="switch">
													<input type="checkbox" id="toggle_steep_material_states" class="optional-input-toggle">
													<span class="slider"></span>       
													</label>
												</div>
												<div id="steep_material_states_group" class="optional-input-content" style="display: none;">
													<div class="form-group">
														<label for="steep_material_states">Block States (JSON Object):</label>
														<textarea id="steep_material_states" rows="2" placeholder="{&quot;state_name&quot;: &quot;value&quot;}"></textarea>
														<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
															<span class="tooltiptext">Contains members named after each state, with boolean, integer, or string values. Example: {"direction": "north"}</span>
														</div>
													</div>
												</div>
											</div>
										</div>
										<div class="switch-container">
											<label for="steep_north_slopes">North Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_north_slopes">
											<span class="slider"></span>    
											</label>
										</div>
										<div class="switch-container">
											<label for="steep_south_slopes">South Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_south_slopes">
											<span class="slider"></span>                  </label>
										</div>
										<div class="switch-container">
											<label for="steep_east_slopes">East Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_east_slopes">
											<span class="slider"></span>  
											</label>
										</div>
										<div class="switch-container">
											<label for="steep_west_slopes">West Slopes:</label>
											<label class="switch">
											<input type="checkbox" id="steep_west_slopes">
											<span class="slider"></span>    
											</label>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:surface_material_adjustments -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="surface_material_adjustments-content">
						<span class="component-title">surface adjustments</span>
						<label class="switch">
						<input type="checkbox" id="enable_surface_material_adjustments" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="surface_material_adjustments-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Specify fine-detail changes to blocks used in terrain generation (based on a noise function).</p>
							<div id="material_adjustments_container">
								<h4>Adjustments (List of Surface Adjustment Settings)</h4>
								<button type="button" class="button add-button" id="add_material_adjustment">
								<span class="material-symbols-rounded">add</span>
								Add Material Adjustment
								</button>
							</div>
						</div>
					</div>
				</div>
				<!-- Group 5: Biome Transformations & Replacements -->
				<!-- Component: minecraft:overworld_generation_rules is no longer here -->
				<!-- Component: minecraft:replace_biomes -->
				<h3>Replace Biomes</h3>
				<div class="component-section single">
					<h3 class="collapsible-header collapsed" data-target="replace_biomes-content">
						<span class="component-title">replace biomes</span>
						<label class="switch">
						<input type="checkbox" id="enable_replace_biomes" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="replace_biomes-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
						    <h4 style="color: var(--md-sys-color-outline-variant)" class="dialog-header"><span class="material-symbols-rounded">info</span> Needed to generate custom biomes.</h4>
							<p>Replaces a specified portion of one or more Minecraft biomes. Can define multiple replacement rules.</p>
							<p>
						        <code>Don't mention same biome names in multiple replacement rules targeted biomes field!</code>
						    </p>
							<div id="replacements_list_container">
								<h4>Replacements</h4>
							</div>
							<button type="button" class="button add-button" id="add_replacement_button" style="margin-top: 10px;">
							<span class="material-symbols-rounded">add</span>
							Add Replacement
							</button>
						</div>
					</div>
				</div>
				<!-- Group 6: Tags & Spawning -->
				<h3>Tags &amp; Spawning &amp; Map Tints</h3>
				<!-- Component: minecraft:tags -->
				<div class="component-section start">
					<h3 class="collapsible-header collapsed" data-target="tags-content">
						<span class="component-title">tags</span>
						<label class="switch">
						<input type="checkbox" id="enable_tags" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="tags-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Attach arbitrary string tags to this biome.</p>
							<div class="form-group">
								<label for="biome_tags_select">Predefined Tags (Multi-select):</label>
								<select id="biome_tags_select" multiple="" size="8">
									<option value="animal">animal</option>
									<option value="ash">ash</option>
									<option value="bamboo">bamboo</option>
									<option value="basalt_deltas">basalt_deltas</option>
									<option value="beach">beach</option>
									<option value="bee_habitat">bee_habitat</option>
									<option value="birch">birch</option>
									<option value="caves">caves</option>
									<option value="cherry_grove">cherry_grove</option>
									<option value="cold">cold</option>
									<option value="crimson_forest">crimson_forest</option>
									<option value="deep">deep</option>
									<option value="deep_dark">deep_dark</option>
									<option value="desert">desert</option>
									<option value="dripstone_caves">dripstone_caves</option>
									<option value="edge">edge</option>
									<option value="extreme_hills">extreme_hills</option>
									<option value="flower_forest">flower_forest</option>
									<option value="forest">forest</option>
									<option value="forest_generation">forest_generation</option>
									<option value="frozen">frozen</option>
									<option value="frozen_peaks">frozen_peaks</option>
									<option value="grove">grove</option>
									<option value="has_structure_trail_ruins">has_structure_trail_ruins</option>
									<option value="hills">hills</option>
									<option value="ice">ice</option>
									<option value="ice_plains">ice_plains</option>
									<option value="jagged_peaks">jagged_peaks</option>
									<option value="jungle">jungle</option>
									<option value="lukewarm">lukewarm</option>
									<option value="lush_caves">lush_caves</option>
									<option value="mangrove_swamp">mangrove_swamp</option>
									<option value="meadow">meadow</option>
									<option value="mega">mega</option>
									<option value="mesa">mesa</option>
									<option value="monster">monster</option>
									<option value="mooshroom_island">mooshroom_island</option>
									<option value="mountain">mountain</option>
									<option value="mountains">mountains</option>
									<option value="mutated">mutated</option>
									<option value="nether">nether</option>
									<option value="nether_wastes">nether_wastes</option>
									<option value="netherwart_forest">netherwart_forest</option>
									<option value="no_legacy_worldgen">no_legacy_worldgen</option>
									<option value="ocean">ocean</option>
									<option value="overworld">overworld</option>
									<option value="overworld_generation">overworld_generation</option>
									<option value="pale_garden">pale_garden</option>
									<option value="plains">plains</option>
									<option value="plateau">plateau</option>
									<option value="rare">rare</option>
									<option value="river">river</option>
									<option value="roofed">roofed</option>
									<option value="savanna">savanna</option>
									<option value="shore">shore</option>
									<option value="snowy_slopes">snowy_slopes</option>
									<option value="soulsand_valley">soulsand_valley</option>
									<option value="spawn_endermen">spawn_endermen</option>
									<option value="spawn_few_piglins">spawn_few_piglins</option>
									<option value="spawn_few_zombified_piglins">spawn_few_zombified_piglins</option>
									<option value="spawn_ghast">spawn_ghast</option>
									<option value="spawn_magma_cubes">spawn_magma_cubes</option>
									<option value="spawn_many_magma_cubes">spawn_many_magma_cubes</option>
									<option value="spawn_piglin">spawn_piglin</option>
									<option value="spawn_zombified_piglin">spawn_zombified_piglin</option>
									<option value="stone">stone</option>
									<option value="stony_peaks">stony_peaks</option>
									<option value="swamp">swamp</option>
									<option value="taiga">taiga</option>
									<option value="the_end">the_end</option>
									<option value="underwater">underwater</option>
									<option value="warm">warm</option>
									<option value="warped_forest">warped_forest</option>
								</select>
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Select tags from a predefined list.</span>
								</div>
							</div>
							<div class="form-group">
								<label for="custom_tag_input">Custom Tag Name:</label>
								<input type="text" id="custom_tag_input" placeholder="e.g., my_custom_tag">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Enter your own custom tag. Tags should be lowercase and can contain alphanumeric characters, periods, and underscores.</span>
								</div>
								<button type="button" class="button add-button" id="add_custom_tag_button">
								<span class="material-symbols-rounded">add</span>
								Add Custom Tag
								</button>
							</div>
							<div id="custom_tags_display" class="tag-list"></div>
						</div>
					</div>
				</div>
				<!-- Component: minecraft:creature_spawn_probability -->
				<div class="component-section">
					<h3 class="collapsible-header collapsed" data-target="creature_spawn_probability-content">
						<span class="component-title">creature probability</span>
						<label class="switch">
						<input type="checkbox" id="enable_creature_spawn_probability" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span> 
					</h3>
					<div id="creature_spawn_probability-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Probability that creatures will spawn within the biome when a chunk is generated.</p>
							<div class="form-group">
								<label for="creature_spawn_probability_value">Probability (Float):</label>
								<input type="number" step="0.01" min="0.0" max="0.75" id="creature_spawn_probability_value" placeholder="e.g., 0.5">
								<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">Probabiltity between [0.0, 0.75] of creatures spawning within the biome on chunk generation.</span>
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- Group 2: Visual Properties -->
				<!-- Component: minecraft:map_tints -->
				<div class="component-section end">
					<h3 class="collapsible-header collapsed" data-target="map_tints-content">
						<span class="component-title">map tints</span>
						<label class="switch">
						<input type="checkbox" id="enable_map_tints" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="map_tints-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<p>Sets the color grass and foliage will be tinted by in this biome on the map.</p>
							<div class="optional-input-container">
								<div class="switch-container">
									<label for="enable_map_tints_foliage">Enable Foliage Tint Color (Optional):</label>
									<label class="switch">
									<input type="checkbox" id="enable_map_tints_foliage" class="optional-input-toggle">
									<span class="slider"></span> </label>
								</div>
								<div id="map_tints_foliage_group" class="optional-input-content" style="display: none;">
									<div class="form-group">
										<label for="map_tints_foliage_color_input">Foliage Tint Color:</label>
										<div class="color-input-group">
											<input type="text" id="map_tints_foliage_color_input" class="color-input-text" placeholder="#RRGGBB or rgb(R,G,B)" value="#6A7039">
											<input type="color" id="map_tints_foliage_color_picker" class="color-input-picker" value="#6A7039">
										</div>
										<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
											<span class="tooltiptext">Sets the color foliage will be tinted by in this biome on the map. Enter as #RRGGBB or rgb(R,G,B).</span>
										</div>
									</div>
								</div>
							</div>
							<h4>Grass Tint Settings (<span class="required-field">Required</span>)</h4>
							<div class="sub-group">
								<div class="radio-group">
									<label class="radio-container">Noise Based Tint
									<input type="radio" name="grass_tint_type" value="noise" id="grass_tint_type_noise" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Custom Tint Color
									<input type="radio" name="grass_tint_type" value="tint" id="grass_tint_type_custom">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div class="form-group" id="grass_custom_tint_group" style="display: none;">
									<label for="grass_custom_tint_color_input" class="required-field">Grass Custom Tint Color:</label>
									<div class="color-input-group">
										<input type="text" id="grass_custom_tint_color_input" class="color-input-text" placeholder="#RRGGBB or rgb(R,G,B)" value="#B6DB61">
										<input type="color" id="grass_custom_tint_color_picker" class="color-input-picker" value="#B6DB61">
									</div>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Tint color used in this biome on the map when 'Custom Tint Color' is selected. Enter as #RRGGBB or rgb(R,G,B).</span>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
								<!-- Group 7: Unused Components for custom biomes, should be not included-->
								<div class="switch-container" style="margin-top: 20px; border-top: 1px solid var(--md-sys-color-outline-variant); padding-top: 15px;">
    <label for="show_unused_components" style="font-size: 1.1em; color: var(--md-sys-color-on-surface);">Unused/Legacy Components</label>
    <label class="switch">
        <input type="checkbox" id="show_unused_components">
        <span class="slider"></span>
    </label>
</div>

<div id="unused_components_wrapper" style="display: none;">
    								<div class="tooltip component-section" style=""><span class="material-symbols-rounded">question_mark</span>
									<span class="tooltiptext">These component are Pre Caves & Cliffs update component and won't customize your custom biomes .</span>
								</div>
				<h3>Unused Components</h3>
				
				<!-- Component: minecraft:overworld_height -->
				
				<div class="component-section start invalid">
				    <h3 class="collapsible-header collapsed" data-target="overworld_height-content">
				        <span class="component-title">overworld height</span>
				        <label class="switch">
				            <input type="checkbox" id="enable_overworld_height" class="component-toggle">
				        </label>
				        <span class="material-symbols-rounded">more</span>
				    </h3>
				    <div id="overworld_height-content" class="component-content" style="display: none;">
				        <div class="menu-divider"></div>
				        <div style="margin: 25px;">
				            <h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> This is a pre-Caves and Cliffs component. It does not change overworld height, and currently only affects map item rendering.</h4>
				            <p>Controls how this biome is instantiated (and then potentially modified) during world generation of the nether.</p>
				            <p>Noise parameters used to drive terrain height in the Overworld.</p>
				            <div class="radio-group">
				                <label class="radio-container">Noise Type
				                    <input type="radio" name="height_config_type" value="noise_type" id="height_noise_type_radio">
				                    <span class="radio-checkmark"></span>
				                </label>
				                <label class="radio-container">Noise Parameters
				                    <input type="radio" name="height_config_type" value="noise_params" id="height_noise_params_radio">
				                    <span class="radio-checkmark"></span>
				                </label>
				            </div>
				            <div id="height_noise_type_group" class="sub-group" style="display: none;">
				                <label for="noise_type_select" class="required-field">Noise Type (String):</label>
				                <select id="noise_type_select">
				                    <option value="">--Select Noise Type--</option>
				                    <option value="default">default</option>
				                    <option value="default_mutated">default_mutated</option>
				                    <option value="river">river</option>
				                    <option value="deep_ocean">deep_ocean</option>
				                    <option value="lowlands">lowlands</option>
				                    <option value="taiga">taiga</option>
				                    <option value="mountains">mountains</option>
				                    <option value="highlands">highlands</option>
				                    <option value="extreme">extreme</option>
				                    <option value="less_extreme">less_extreme</option>
				                    <option value="beach">beach</option>
				                    <option value="stone_beach">stone_beach</option>
				                    <option value="mushroom">mushroom</option>
				                    <option value="swamp">swamp</option>
				                </select>
				                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
				                    <span class="tooltiptext">Specifies a preset based on a built-in setting rather than manually using noise_params.</span>
				                </div>
				            </div>
				            <div id="height_noise_params_group" class="sub-group" style="display: none;">
				                <label>Noise Parameters (Depth, Scale - Array of 2 Floats):</label>
				                <input type="number" step="0.01" id="noise_params_depth" placeholder="e.g., 1.8">
				                <input type="number" step="0.01" id="noise_params_scale" placeholder="e.g., 0.8">
				                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
				                    <span class="tooltiptext">First value is depth - more negative means deeper underwater, while more positive means higher. Second value is scale, which affects how much noise changes as it moves from the surface.</span>
				                </div>
				            </div>
				        </div>
				    </div>
				</div>
				<!-- Component: minecraft:overworld_generation_rules -->
				<div class="component-section invalid">
					<h3 class="collapsible-header collapsed" data-target="overworld_generation_rules-content">
						<span class="component-title">overworld generation</span>
						<label class="switch">
						<input type="checkbox" id="enable_overworld_generation_rules" class="component-toggle">
						</label>
						<span class="material-symbols-rounded">more</span>
					</h3>
					<div id="overworld_generation_rules-content" class="component-content" style="display: none;">
						<div class="menu-divider"></div>
						<div style="margin: 25px;">
							<h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> Pre Caves & Cliffs update component unused for custom biomes.</h4>
							<p>Controls how this biome is instantiated (and then potentially modified) during world generation of the overworld.</p>
							<h4>Generate For Climates</h4>
							<div class="sub-group" id="generate_for_climates_container">
								<p>An array of weighted climate categories.</p>
								<button type="button" class="button add-button" id="add_climate_category">
								<span class="material-symbols-rounded">add</span>
								Add Climate Category
								</button>
							</div>
							<!-- Hills Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Hills Transformation</h4>
								<p>What biome(s) to switch to when converting to a hilly biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="hills_transform_type" value="simple" id="hills_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="hills_transform_type" value="weighted" id="hills_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="hills_transformation_simple_group" class="form-group" style="display: block;">
									<label for="hills_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="hills_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="hills_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_hills_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="hills_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- Mutate Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Mutate Transformation</h4>
								<p>What biome(s) to switch to when converting to a mutated biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="mutate_transform_type" value="simple" id="mutate_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="mutate_transform_type" value="weighted" id="mutate_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="mutate_transformation_simple_group" class="form-group" style="display: block;">
									<label for="mutate_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="mutate_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="mutate_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_mutate_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="mutate_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- River Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>River Transformation</h4>
								<p>What biome(s) to switch to when converting to a river biome (if not the Vanilla 'river' biome).</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="river_transform_type" value="simple" id="river_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="river_transform_type" value="weighted" id="river_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="river_transformation_simple_group" class="form-group" style="display: block;">
									<label for="river_transformation_select" class="required-field">Biome Names (Multi-select):</label>
								
								<select id="river_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="river_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_river_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="river_weighted_biomes_container"></div>
								</div>
							</div>
							<!-- Shore Transformation -->
							<div class="sub-group transformation-radio-group">
								<h4>Shore Transformation</h4>
								<p>What biome(s) to switch to when adjacent to an ocean biome.</p>
								<div class="radio-group">
									<label class="radio-container">Simple Biome List
									<input type="radio" name="shore_transform_type" value="simple" id="shore_transform_type_simple" checked="">
									<span class="radio-checkmark"></span>
									</label>
									<label class="radio-container">Weighted Biome List
									<input type="radio" name="shore_transform_type" value="weighted" id="shore_transform_type_weighted">
									<span class="radio-checkmark"></span>
									</label>
								</div>
								<div id="shore_transformation_simple_group" class="form-group" style="display: block;">
									<label for="shore_transformation_select" class="required-field">Biome Names (Multi-select):</label>
									<select id="shore_transformation_select" multiple="" size="5">
										<option value="minecraft:bamboo_jungle_hills">minecraft:bamboo_jungle_hills</option>
										<option value="minecraft:bamboo_jungle">minecraft:bamboo_jungle</option>
										<option value="minecraft:beach">minecraft:beach</option>
										<option value="minecraft:birch_forest_hills_mutated">minecraft:birch_forest_hills_mutated</option>
										<option value="minecraft:birch_forest_hills">minecraft:birch_forest_hills</option>
										<option value="minecraft:birch_forest_mutated">minecraft:birch_forest_mutated</option>
										<option value="minecraft:birch_forest">minecraft:birch_forest</option>
										<option value="minecraft:cherry_grove">minecraft:cherry_grove</option>
										<option value="minecraft:cold_beach">minecraft:cold_beach</option>
										<option value="minecraft:cold_ocean">minecraft:cold_ocean</option>
										<option value="minecraft:cold_taiga_hills">minecraft:cold_taiga_hills</option>
										<option value="minecraft:cold_taiga_mutated">minecraft:cold_taiga_mutated</option>
										<option value="minecraft:cold_taiga">minecraft:cold_taiga</option>
										<option value="minecraft:deep_cold_ocean">minecraft:deep_cold_ocean</option>
										<option value="minecraft:deep_dark">minecraft:deep_dark</option>
										<option value="minecraft:deep_frozen_ocean">minecraft:deep_frozen_ocean</option>
										<option value="minecraft:deep_lukewarm_ocean">minecraft:deep_lukewarm_ocean</option>
										<option value="minecraft:deep_ocean">minecraft:deep_ocean</option>
										<option value="minecraft:deep_warm_ocean">minecraft:deep_warm_ocean</option>
										<option value="minecraft:desert_hills">minecraft:desert_hills</option>
										<option value="minecraft:desert_mutated">minecraft:desert_mutated</option>
										<option value="minecraft:desert">minecraft:desert</option>
										<option value="minecraft:dripstone_caves">minecraft:dripstone_caves</option>
										<option value="minecraft:extreme_hills_edge">minecraft:extreme_hills_edge</option>
										<option value="minecraft:extreme_hills_mutated">minecraft:extreme_hills_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees_mutated">minecraft:extreme_hills_plus_trees_mutated</option>
										<option value="minecraft:extreme_hills_plus_trees">minecraft:extreme_hills_plus_trees</option>
										<option value="minecraft:extreme_hills">minecraft:extreme_hills</option>
										<option value="minecraft:flower_forest">minecraft:flower_forest</option>
										<option value="minecraft:forest_hills">minecraft:forest_hills</option>
										<option value="minecraft:forest">minecraft:forest</option>
										<option value="minecraft:frozen_ocean">minecraft:frozen_ocean</option>
										<option value="minecraft:frozen_peaks">minecraft:frozen_peaks</option>
										<option value="minecraft:frozen_river">minecraft:frozen_river</option>
										<option value="minecraft:grove">minecraft:grove</option>
										<option value="minecraft:ice_mountains">minecraft:ice_mountains</option>
										<option value="minecraft:ice_plains_spikes">minecraft:ice_plains_spikes</option>
										<option value="minecraft:ice_plains">minecraft:ice_plains</option>
										<option value="minecraft:jagged_peaks">minecraft:jagged_peaks</option>
										<option value="minecraft:jungle_edge_mutated">minecraft:jungle_edge_mutated</option>
										<option value="minecraft:jungle_edge">minecraft:jungle_edge</option>
										<option value="minecraft:jungle_hills">minecraft:jungle_hills</option>
										<option value="minecraft:jungle_mutated">minecraft:jungle_mutated</option>
										<option value="minecraft:jungle">minecraft:jungle</option>
										<option value="minecraft:legacy_frozen_ocean">minecraft:legacy_frozen_ocean</option>
										<option value="minecraft:lukewarm_ocean">minecraft:lukewarm_ocean</option>
										<option value="minecraft:lush_caves">minecraft:lush_caves</option>
										<option value="minecraft:mangrove_swamp">minecraft:mangrove_swamp</option>
										<option value="minecraft:meadow">minecraft:meadow</option>
										<option value="minecraft:mega_taiga_hills">minecraft:mega_taiga_hills</option>
										<option value="minecraft:mega_taiga">minecraft:mega_taiga</option>
										<option value="minecraft:mesa_bryce">minecraft:mesa_bryce</option>
										<option value="minecraft:mesa_plateau_mutated">minecraft:mesa_plateau_mutated</option>
										<option value="minecraft:mesa_plateau_stone_mutated">minecraft:mesa_plateau_stone_mutated</option>
										<option value="minecraft:mesa_plateau_stone">minecraft:mesa_plateau_stone</option>
										<option value="minecraft:mesa_plateau">minecraft:mesa_plateau</option>
										<option value="minecraft:mesa">minecraft:mesa</option>
										<option value="minecraft:mushroom_island_shore">minecraft:mushroom_island_shore</option>
										<option value="minecraft:mushroom_island">minecraft:mushroom_island</option>
										<option value="minecraft:ocean">minecraft:ocean</option>
										<option value="minecraft:pale_garden">minecraft:pale_garden</option>
										<option value="minecraft:plains">minecraft:plains</option>
										<option value="minecraft:redwood_taiga_hills_mutated">minecraft:redwood_taiga_hills_mutated</option>
										<option value="minecraft:redwood_taiga_mutated">minecraft:redwood_taiga_mutated</option>
										<option value="minecraft:river">minecraft:river</option>
										<option value="minecraft:roofed_forest_mutated">minecraft:roofed_forest_mutated</option>
										<option value="minecraft:roofed_forest">minecraft:roofed_forest</option>
										<option value="minecraft:savanna_mutated">minecraft:savanna_mutated</option>
										<option value="minecraft:savanna_plateau_mutated">minecraft:savanna_plateau_mutated</option>
										<option value="minecraft:savanna_plateau">minecraft:savanna_plateau</option>
										<option value="minecraft:savanna">minecraft:savanna</option>
										<option value="minecraft:snowy_slopes">minecraft:snowy_slopes</option>
										<option value="minecraft:stone_beach">minecraft:stone_beach</option>
										<option value="minecraft:stony_peaks">minecraft:stony_peaks</option>
										<option value="minecraft:sunflower_plains">minecraft:sunflower_plains</option>
										<option value="minecraft:swampland_mutated">minecraft:swampland_mutated</option>
										<option value="minecraft:swampland">minecraft:swampland</option>
										<option value="minecraft:taiga_hills">minecraft:taiga_hills</option>
										<option value="minecraft:taiga_mutated">minecraft:taiga_mutated</option>
										<option value="minecraft:taiga">minecraft:taiga</option>
										<option value="minecraft:warm_ocean">minecraft:warm_ocean</option>
									</select>
									<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
										<span class="tooltiptext">Select one or more biome names.</span>
									</div>
								</div>
								<div id="shore_transformation_weighted_group" class="sub-group" style="display: none;">
									<h4>Weighted Biomes</h4>
									<button type="button" class="button add-button" id="add_shore_weighted_biome">
									<span class="material-symbols-rounded">add</span>
									Add Weighted Biome
									</button>
									<div id="shore_weighted_biomes_container"></div>
								</div>
							</div>
						</div>
					</div>
				</div>	
				<!-- Component: minecraft:multinoise_generation_rules -->
				<div class="component-section end invalid">
				    <h3 class="collapsible-header collapsed" data-target="multinoise_generation_rules-content">
				        <span class="component-title">multinoise generation</span>
				        <label class="switch">
				            <input type="checkbox" id="enable_multinoise_generation_rules" class="component-toggle">
				        </label>
				        <span class="material-symbols-rounded">more</span>
				    </h3>
				    <div id="multinoise_generation_rules-content" class="component-content" style="display: none;">
				        <div class="menu-divider"></div>
				        <div style="margin: 25px;">
				            <h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span> Pre Caves & Cliffs update component unused for custom biomes.</h4>
				            <p>Controls how this biome is instantiated (and then potentially modified) during world generation of the nether.</p>
				            <div class="form-group">
				                <label for="multinoise_target_altitude">Target Altitude (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_altitude" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_humidity">Target Humidity (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_humidity" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_temperature">Target Temperature (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_temperature" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_target_weirdness">Target Weirdness (Float):</label>
				                <input type="number" step="0.01" id="multinoise_target_weirdness" placeholder="e.g., 0.0">
				            </div>
				            <div class="form-group">
				                <label for="multinoise_weight">Weight (Float):</label>
				                <input type="number" step="0.01" id="multinoise_weight" placeholder="e.g., 1.0">
				            </div>
				        </div>
				    </div>
				</div></div>
			</form>
			<div id="hidden-container">
			    <div class="menu-divider"></div>
				<form id="clientBiomeForm">
					<h2>Client Biome Components</h2>
					
					<p><code>Select the visual and audio components you wish to include in your client biome definition.</code></p>
					<div class="menu-divider"></div>
					<h3>Visual Appearance</h3>
					<div class="component-section start">
						<h3 class="collapsible-header collapsed" data-target="sky_color-content">
							<span class="component-title">sky_color</span>
							<label class="switch">
							<input type="checkbox" id="comp_sky_color" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="sky_color-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Sky color (hex)</label>
									<div class="color-input-group">
										<input type="text" id="sky_color_hex_text" class="color-input-text" value="#88AAFF" placeholder="#RRGGBB">
										<input type="color" id="sky_color_hex" class="color-input-picker" value="#88aaff">
									</div>
								</div>
								<div class="form-group">
									<label>Or RGB array</label>
									<input id="sky_color_arr" type="text" placeholder="[136,170,255]">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="water_appearance-content">
							<span class="component-title">water_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_water_appearance" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="water_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Surface color</label>
									<div class="color-input-group">
										<input type="text" id="water_surface_color_text" class="color-input-text" value="#4455FF" placeholder="#RRGGBB">
										<input type="color" id="water_surface_color" class="color-input-picker" value="#4455ff">
									</div>
								</div>
								<div class="form-group">
									<label>Surface opacity (0.0–1.0)</label>
									<input id="water_surface_opacity" type="number" min="0" max="1" step="0.01" value="1.0">
								</div>
								<div class="form-group">
									<label>Water identifier (Vibrant Visuals)</label>
									<input id="water_identifier" type="text" placeholder="namespace:water_definition">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="fog_appearance-content">
							<span class="component-title">fog_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_fog" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="fog_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Fog identifier</label>
									<input id="fog_identifier" type="text" placeholder="namespace:fog_definition">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="foliage_appearance-content">
							<span class="component-title">foliage_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_foliage" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="foliage_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Use color picker</label>
									<div class="color-input-group">
										<input type="text" id="foliage_color_hex_text" class="color-input-text" value="#55AA33" placeholder="#RRGGBB">
										<input type="color" id="foliage_color_hex" class="color-input-picker" value="#55aa33">
									</div>
								</div>
								<div class="form-group">
									<label>Or color map</label>
									<select id="foliage_color_map">
										<option value="">-- none --</option>
										<option value="foliage">foliage</option>
										<option value="birch">birch</option>
										<option value="evergreen">evergreen</option>
										<option value="mangrove_swamp_foliage">mangrove_swamp_foliage</option>
										<option value="swamp_foliage">swamp_foliage</option>
										<option value="dry_foliage">dry_foliage</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="grass_appearance-content">
							<span class="component-title">grass_appearance</span>
							<label class="switch">
							<input type="checkbox" id="comp_grass" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="grass_appearance-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Use color picker</label>
									<div class="color-input-group">
										<input type="text" id="grass_color_hex_text" class="color-input-text" value="#77CC44" placeholder="#RRGGBB">
										<input type="color" id="grass_color_hex" class="color-input-picker" value="#77cc44">
									</div>
								</div>
								<div class="form-group">
									<label>Or color map</label>
									<select id="grass_color_map">
										<option value="">-- none --</option>
										<option value="grass">grass</option>
										<option value="swamp_grass">swamp_grass</option>
									</select>
								</div>
								<div class="switch-container">
									<label for="grass_is_shaded">grass_is_shaded (adds roof-like shading)</label>
									<label class="switch">
									<input type="checkbox" id="grass_is_shaded">
									<span class="slider"></span>
									</label>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section end">
						<h3 class="collapsible-header collapsed" data-target="dry_foliage_color-content">
							<span class="component-title">dry_foliage_color</span>
							<label class="switch">
							<input type="checkbox" id="comp_dry_foliage" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="dry_foliage_color-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Dry foliage color (picker)</label>
									<div class="color-input-group">
										<input type="text" id="dry_foliage_hex_text" class="color-input-text" value="#AAAAAA" placeholder="#RRGGBB">
										<input type="color" id="dry_foliage_hex" class="color-input-picker" value="#aaaaaa">
									</div>
								</div>
								<div class="form-group">
									<label>Or RGB array</label>
									<input id="dry_foliage_array" type="text" placeholder="[170,170,170]">
								</div>
							</div>
						</div>
					</div>
					<h3>Precipitation</h3>
					
					<div class="component-section single">
						<h3 class="collapsible-header collapsed" data-target="precipitation-content">
							<span class="component-title">precipitation</span>
							<label class="switch">
								<input type="checkbox" id="comp_precip" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="precipitation-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Mode</label>
									<select id="precip_mode">
										<option value="single">Single (recommended)</option>
										<option value="advanced">Advanced (allow multiple)</option>
									</select>
						<div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
    <span class="tooltiptext">Don't change it.</span>
</div>		</div>
								<div id="precip_single" class="sub-group">
									<div class="form-group">
										<label>Type</label>
										<select id="precip_type">
											<option value="">-- select --</option>
											<option value="ash">ash</option>
											<option value="blue_spores">blue_spores</option>
											<option value="red_spores">red_spores</option>
											<option value="white_ash">white_ash</option>
										</select>
									</div>
									<div class="form-group">
										<label>Density (float)</label>
										<input id="precip_density" type="number" step="0.01" min="0" placeholder="e.g. 0.5">
									</div>
								</div>
								<div id="precip_advanced" class="sub-group" style="display:none;">
					<h4 style="color: var(--md-sys-color-error)" class="dialog-header"><span class="material-symbols-rounded">warning</span>You may face error console logs and it may not appear properly in your world!</h4>				<div class="form-group">
										<label>ash</label>
										<input id="precip_ash" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>blue_spores</label>
										<input id="precip_blue_spores" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>red_spores</label>
										<input id="precip_red_spores" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
									<div class="form-group">
										<label>white_ash</label>
										<input id="precip_white_ash" type="number" step="0.01" min="0" placeholder="0.0">
									</div>
								</div>
							</div>
						</div>
					</div>
					<h3>Vibrant Visuals Identifiers</h3>
					
					<div class="component-section start">
						<h3 class="collapsible-header collapsed" data-target="atmosphere-content">
							<span class="component-title">atmosphere</span>
							<label class="switch">
							<input type="checkbox" id="comp_atmosphere" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="atmosphere-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Atmosphere identifier</label>
									<input id="atmosphere_identifier" type="text" placeholder="namespace:atmosphere_definition">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="color_grading-content">
							<span class="component-title">color_grading</span>
							<label class="switch">
							<input type="checkbox" id="comp_color_grading" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="color_grading-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Color grading identifier</label>
									<input id="color_grading_identifier" type="text" placeholder="namespace:color_grading">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section">
						<h3 class="collapsible-header collapsed" data-target="cubemap-content">
							<span class="component-title">cubemap</span>
							<label class="switch">
							<input type="checkbox" id="comp_cubemap" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="cubemap-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Cubemap identifier</label>
									<input id="cubemap_identifier" type="text" placeholder="namespace:cubemap_definition">
								</div>
							</div>
						</div>
					</div>
					<div class="component-section end">
						<h3 class="collapsible-header collapsed" data-target="lighting-content">
							<span class="component-title">lighting</span>
							<label class="switch">
							<input type="checkbox" id="comp_lighting" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="lighting-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Lighting identifier</label>
									<input id="lighting_identifier" type="text" placeholder="namespace:lighting_definition">
								</div>
							</div>
						</div>
					</div>
					<h3>Music & Ambient</h3>
					<div class="component-section start">
						<h3 class="collapsible-header collapsed" data-target="ambient_sounds-content">
							<span class="component-title">ambient_sounds</span>
							<label class="switch">
							<input type="checkbox" id="comp_ambient" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="ambient_sounds-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Loop sound (named sound reference)</label>
									<input id="ambient_loop" type="text" placeholder="namespace:sound_loop">
								</div>
								<div class="form-group">
									<label>Addition (occasional) – asset</label>
									<input id="ambient_add_asset" type="text" placeholder="namespace:sound_add_asset">
								</div>
								<div class="form-group">
									<label>Addition (occasional) – chance</label>
									<input id="ambient_add_chance" type="number" min="0" max="1" step="0.01" placeholder="chance 0.0–1.0">
								</div>
								<div class="form-group">
									<label>Mood (rare, low-light) reference</label>
									<input id="ambient_mood" type="text" placeholder="namespace:sound_mood">
								</div>
								<div class="menu-divider"></div>
								<div class="switch-container">
									<label for="comp_underwater_ambient">Enable Underwater ambient sounds</label>
									<label class="switch">
									<input type="checkbox" id="comp_underwater_ambient">
									<span class="slider"></span>
									</label>
								</div>
								<div id="underwater_ambient_block" class="sub-group" style="display:none;">
									<div class="form-group">
										<label>Underwater addition (asset)</label>
										<input id="underwater_add_asset" type="text" placeholder="namespace:underwater_add_asset">
									</div>
									<div class="form-group">
										<label>Underwater addition (chance)</label>
										<input id="underwater_add_chance" type="number" min="0" max="1" step="0.01" placeholder="chance 0.0–1.0">
									</div>
									<div class="form-group">
										<label>Underwater loop</label>
										<input id="underwater_loop" type="text" placeholder="namespace:underwater_loop">
									</div>
									<div class="form-group">
										<label>Underwater mood (rare)</label>
										<input id="underwater_mood" type="text" placeholder="namespace:underwater_mood">
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="component-section end">
						<h3 class="collapsible-header collapsed" data-target="biome_music-content">
							<span class="component-title">biome_music</span>
							<label class="switch">
							<input type="checkbox" id="comp_music" class="component-toggle">
							</label>
							<span class="material-symbols-rounded">more</span>
						</h3>
						<div id="biome_music-content" class="component-content">
							<div class="menu-divider"></div>
							<div style="margin: 25px;">
								<div class="form-group">
									<label>Music definition (reference)</label>
									<input id="music_definition" type="text" placeholder="namespace:music_definition">
								</div>
								<div class="form-group">
									<label>Volume multiplier (0–1)</label>
									<input id="music_volume" type="number" min="0" max="1" step="0.01" value="1.0">
								</div>
								<div class="form-group">
									<label>Enable underwater music?</label>
									<select id="music_underwater">
										<option value="">-- default --</option>
										<option value="true">true</option>
										<option value="false">false</option>
									</select>
								</div>
							</div>
						</div>
					</div>
				</form>
			</div>
		</div>
		<!-- Custom Modal HTML -->
		<div id="modalOverlay" class="modal-overlay" style="display: none;">
			<div class="modal-box">
				<h4 id="modalTitle"></h4>
				<p id="modalContent"></p>
				<input type="text" id="modalInput" class="modal-input" style="display: none;">
				<div class="modal-buttons">
					<button id="modalCancelButton" class="secondary">Cancel</button>
					<button id="modalConfirmButton">Confirm</button>
				</div>
			</div>
		</div>
		<!-- Multi-Export Modal -->
		<div id="multiExportModalOverlay" class="modal-overlay" style="display: none;">
			<div class="modal-box" style="max-width: 500px; text-align: left;">
				<h4>Export Multiple Presets</h4>
				<p>Select the presets you want to include in the .mcpack file.</p>
				<div class="form-group">
					<label for="mcpackNameInput" class="required-field">Pack Name:</label>
					<input type="text" id="mcpackNameInput" class="modal-input" placeholder="e.g., My Awesome Biomes">
				</div>
				<div id="multiExportPresetList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--md-sys-color-outline); border-radius: 8px; padding: 10px; margin-bottom: 20px;">
					<!-- Preset checkboxes will be dynamically inserted here -->
				</div>
				<div class="modal-buttons">
					<button id="multiExportCancelButton" class="secondary">Cancel</button>
					<button id="multiExportConfirmButton">Export .mcpack</button>
				</div>
			</div>
		</div>
		<!-- Snackbar/Toast Bar -->
		<div id="snackbar" class="snackbar">Form values reset!</div>
		<!-- Scroller custom -->
		<div id="fastScrollTrack" class="fast-scroll-track">
    <div id="fastScrollThumb" class="fast-scroll-thumb">
        <span class="material-symbols-rounded">unfold_more</span>
    </div>
</div>

<!-- ADDED: Theme Picker Modal -->
<div id="themeModalOverlay" class="modal-overlay" style="display: none;">
    <div class="modal-box" style="width: 100%; max-width: 600px;">
        <h4>Select Color Theme</h4>
        <p>Choose a color palette to personalize the app.</p>
        
        <div id="themeListContainer" class="theme-grid">
            <!-- Themes will be generated here by JS -->
        </div>

        <div class="modal-buttons">
            <button id="closeThemeModal" class="secondary">Close</button>
        </div>
    </div>
</div>
<!-- END ADDED -->

		<script src="jszip.min.js" crossorigin="anonymous"></script>
		<script>
			// --- Global Constants & State ---
			const PRESET_STORAGE_KEY = 'bibuild_presets';
			let customTags = [];
			
			// --- Utility & Helper Functions ---
			
			function generateUuidv4() {
			    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
			        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
			        return v.toString(16);
			    });
			}
			
			// Custom Modal Function
			function showModal({ title, message, needsInput = false, onConfirm, onCancel }) {
			    const overlay = document.getElementById('modalOverlay');
			    document.getElementById('modalTitle').textContent = title;
			    document.getElementById('modalContent').textContent = message;
			    
			    const input = document.getElementById('modalInput');
			    input.style.display = needsInput ? 'block' : 'none';
			    input.value = '';
			
			    overlay.style.display = 'flex';
			
			    const confirmButton = document.getElementById('modalConfirmButton');
			    const cancelButton = document.getElementById('modalCancelButton');
			
			    // Clone and replace buttons to remove old event listeners
			    const newConfirmButton = confirmButton.cloneNode(true);
			    const newCancelButton = cancelButton.cloneNode(true);
			    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
			    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
			
			    newConfirmButton.addEventListener('click', () => {
			        overlay.style.display = 'none';
			        if (onConfirm) onConfirm(needsInput ? input.value : true);
			    });
			    newCancelButton.addEventListener('click', () => {
			        overlay.style.display = 'none';
			        if (onCancel) onCancel();
			    });
			    
			    if(needsInput) input.focus();
			}
			
			// Snackbar/Toast Bar Function
			function showSnackbar(message) {
			    const snackbar = document.getElementById('snackbar');
			    snackbar.textContent = message;
			    snackbar.classList.add('show');
			    setTimeout(() => snackbar.classList.remove('show'), 3000);
			}
			
			// --- JSON Generation and Form Population ---
			
			function getJsonFromForm() {
			    return generateFullBiomeJson(); 
			}
			
			function populateFormFromJson(jsonData) {
			    resetForm(); 
			    try {
			        _populateFormFromJson(jsonData); 
			        showSnackbar('Data loaded into form successfully!');
			    } catch (error) {
			        showModal({
			            title: 'Load Error',
			            message: `Failed to load data into form: ${error.message}`,
			            onConfirm: () => {}
			        });
			        console.error("Population Error:", error);
			        resetForm(); 
			    }
			}
			
			
			// --- Preset Management ---
			
			function getPresets() {
			    try {
			        const presets = localStorage.getItem(PRESET_STORAGE_KEY);
			        return presets ? JSON.parse(presets) : {};
			    } catch (e) {
			        console.error("Could not parse presets from localStorage", e);
			        return {};
			    }
			}
			
			function savePresets(presets) {
			    localStorage.setItem(PRESET_STORAGE_KEY, JSON.stringify(presets));
			}
			
			function updatePresetDropdown() {
			    const presets = getPresets();
			    const presetNames = Object.keys(presets).sort();
			    const select = document.getElementById('presetLoadSelect');
			    select.innerHTML = '';
			
			    if (presetNames.length === 0) {
			        select.innerHTML = '<option value="">-- No Presets Found --</option>';
			    } else {
			        presetNames.forEach(name => {
			            const option = document.createElement('option');
			            option.value = name;
			            option.textContent = name;
			            select.appendChild(option);
			        });
			    }
			}
			
			function handleSavePreset() {
    let serverJson, clientJson;

    // 1. Generate Server JSON
    try {
        serverJson = generateFullBiomeJson();
    } catch (error) {
        showModal({
            title: 'Cannot Save Preset',
            message: `Server Biome Error: ${error.message}`,
            onConfirm: () => {}
        });
        return;
    }

    // 2. Generate Client JSON
    try {
        // Re-use the input values and global buildComponents function
        const identifier = document.getElementById('identifier').value.trim().toLowerCase();
        const fv = document.getElementById('format_version').value.trim();
        
        // buildComponents() gathers data from the Client form
        const clientComponents = buildComponents(); 
        
        clientJson = {
            "format_version": fv,
            "minecraft:client_biome": {
                "description": { "identifier": identifier },
                "components": clientComponents
            }
        };
    } catch (error) {
        showModal({
            title: 'Cannot Save Preset',
            message: `Client Biome Error: ${error}`, // buildComponents throws strings, not Error objects
            onConfirm: () => {}
        });
        return;
    }

    // 3. Save Both to LocalStorage
    showModal({
        title: 'Save Preset',
        message: 'Enter a name for your preset:',
        needsInput: true,
        onConfirm: (presetName) => {
            if (!presetName || presetName.trim() === '') {
                showSnackbar('Preset name cannot be empty.');
                return;
            }
            const presets = getPresets();
            
            // Store as a composite object
            presets[presetName.trim()] = {
                server: serverJson,
                client: clientJson
            };
            
            savePresets(presets);
            updatePresetDropdown();
            showSnackbar(`Preset "${presetName.trim()}" saved (Server & Client)!`);
        }
    });
}

			
			function handleLoadPreset() {
    const select = document.getElementById('presetLoadSelect');
    const presetName = select.value;
    if (!presetName) {
        showSnackbar('No preset selected.');
        return;
    }
    const presets = getPresets();
    const presetData = presets[presetName];
    
    if (presetData) {
        // Reset both forms first to ensure a clean slate
        resetForm();
        
        // Check if this is the new Combined format (has 'server' and 'client' keys)
        if (presetData.server && presetData.client) {
            
            // 1. Load Server Data
            try {
                _populateFormFromJson(presetData.server);
                // Update Server Preview
                document.getElementById('jsonOutput').textContent = JSON.stringify(presetData.server, null, 2);
            } catch (e) {
                console.error("Error loading server part of preset", e);
            }

            // 2. Load Client Data
            try {
                if (typeof populateClientForm === 'function') {
                    populateClientForm(presetData.client);
                    // Update Client Preview
                    document.getElementById('outputJson').textContent = JSON.stringify(presetData.client, null, 2);
                }
            } catch (e) {
                console.error("Error loading client part of preset", e);
            }

            showSnackbar(`Preset "${presetName}" loaded (Server & Client)!`);
            
        } else {
            // Fallback for Legacy Presets (Server JSON only)
            try {
                _populateFormFromJson(presetData);
                document.getElementById('jsonOutput').textContent = JSON.stringify(presetData, null, 2);
                showSnackbar(`Legacy preset "${presetName}" loaded (Server Only).`);
            } catch (e) {
                 showModal({
                    title: 'Error',
                    message: `Failed to load legacy preset: ${e.message}`,
                    onConfirm: () => {}
                });
            }
        }
    } else {
         showModal({
            title: 'Error',
            message: `Could not find data for preset "${presetName}".`,
            onConfirm: () => {}
        });
    }
}

			
			function handleDeletePreset() {
			    const select = document.getElementById('presetLoadSelect');
			    const presetName = select.value;
			    if (!presetName) {
			        showSnackbar('No preset selected to delete.');
			        return;
			    }
			
			    showModal({
			        title: 'Delete Preset',
			        message: `Are you sure you want to delete the preset "${presetName}"? This cannot be undone.`,
			        onConfirm: () => {
			            const presets = getPresets();
			            delete presets[presetName];
			            savePresets(presets);
			            updatePresetDropdown();
			            showSnackbar(`Preset "${presetName}" deleted.`);
			        }
			    });
			}
			
			// --- Multi-Export Functionality ---
    function handleExportMultiple() {
    const presets = getPresets();
    const presetNames = Object.keys(presets).sort();
    const presetListContainer = document.getElementById('multiExportPresetList');
    const modalOverlay = document.getElementById('multiExportModalOverlay');
    
    presetListContainer.innerHTML = ''; // Clear previous list

    if (presetNames.length === 0) {
        showSnackbar("No saved presets to export.");
        return;
    }

    // --- ADDED: Select All Option ---
    const selectAllWrapper = document.createElement('div');
    selectAllWrapper.className = 'preset-item-container';
    selectAllWrapper.style.backgroundColor = 'var(--md-sys-color-surface-variant)';
    selectAllWrapper.style.borderRadius = '8px';
    selectAllWrapper.style.marginBottom = '10px';
    
    const selectAllHeader = document.createElement('div');
    selectAllHeader.className = 'preset-header';
    selectAllHeader.style.padding = '10px';

    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.id = 'select_all_presets';
    
    const selectAllLabel = document.createElement('label');
    selectAllLabel.htmlFor = 'select_all_presets';
    selectAllLabel.textContent = "Select All Presets";
    
    selectAllHeader.appendChild(selectAllCheckbox);
    selectAllHeader.appendChild(selectAllLabel);
    selectAllWrapper.appendChild(selectAllHeader);
    presetListContainer.appendChild(selectAllWrapper);
    // --------------------------------

    presetNames.forEach(name => {
        const data = presets[name];
        const hasServer = !!(data.server || data['minecraft:biome']);
        const hasClient = !!(data.client);

        const wrapper = document.createElement('div');
        wrapper.className = 'preset-item-container';

        const header = document.createElement('div');
        header.className = 'preset-header';

        const mainCheckbox = document.createElement('input');
        mainCheckbox.type = 'checkbox';
        mainCheckbox.id = `preset_main_${name}`;
        mainCheckbox.dataset.presetName = name;
        mainCheckbox.checked = false; // CHANGED: Default to unchecked

        const label = document.createElement('label');
        label.htmlFor = `preset_main_${name}`;
        label.textContent = name;

        const expandBtn = document.createElement('button');
        expandBtn.className = 'preset-expand-btn';
        expandBtn.innerHTML = '<span class="material-symbols-rounded">expand_more</span>';
        
        header.appendChild(mainCheckbox);
        header.appendChild(label);
        header.appendChild(expandBtn);

        const details = document.createElement('div');
        details.className = 'preset-details';
        // Initially disable details opacity since main is unchecked
        details.style.opacity = '0.5'; 
        details.style.pointerEvents = 'none';

        if (hasServer) {
            const sDiv = document.createElement('div');
            sDiv.className = 'sub-file-option';
            sDiv.innerHTML = `
                <input type="checkbox" id="sub_server_${name}" checked>
                <label for="sub_server_${name}">Server Biome</label>
                <span class="badge">BP</span>`;
            details.appendChild(sDiv);
        }

        if (hasClient) {
            const cDiv = document.createElement('div');
            cDiv.className = 'sub-file-option';
            cDiv.innerHTML = `
                <input type="checkbox" id="sub_client_${name}" checked>
                <label for="sub_client_${name}">Client Biome</label>
                <span class="badge">RP</span>`;
            details.appendChild(cDiv);
        } else {
            const noClient = document.createElement('div');
            noClient.className = 'sub-file-option';
            noClient.style.opacity = '0.5';
            noClient.innerHTML = `<span class="material-symbols-rounded" style="font-size:16px; margin-right:5px;">block</span> No Client Data`;
            details.appendChild(noClient);
        }

        wrapper.appendChild(header);
        wrapper.appendChild(details);
        presetListContainer.appendChild(wrapper);

        expandBtn.addEventListener('click', (e) => {
            e.preventDefault();
            const isHidden = details.style.display === 'none' || details.style.display === '';
            details.style.display = isHidden ? 'block' : 'none';
            expandBtn.classList.toggle('expanded', isHidden);
        });

        mainCheckbox.addEventListener('change', () => {
            details.style.opacity = mainCheckbox.checked ? '1' : '0.5';
            details.style.pointerEvents = mainCheckbox.checked ? 'auto' : 'none';
            
            // Update "Select All" state if individual clicked
            if (!mainCheckbox.checked) selectAllCheckbox.checked = false;
        });
    });

    // --- ADDED: Select All Logic ---
    selectAllCheckbox.addEventListener('change', () => {
        const allMain = document.querySelectorAll('#multiExportPresetList input[type="checkbox"][id^="preset_main_"]');
        allMain.forEach(cb => {
            cb.checked = selectAllCheckbox.checked;
            cb.dispatchEvent(new Event('change')); // Trigger opacity change logic
        });
    });
    // -------------------------------

    modalOverlay.style.display = 'flex';

    const confirmButton = document.getElementById('multiExportConfirmButton');
    const cancelButton = document.getElementById('multiExportCancelButton');

    const newConfirmButton = confirmButton.cloneNode(true);
    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
    
    const newCancelButton = cancelButton.cloneNode(true);
    cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

    newConfirmButton.addEventListener('click', processMultiExport);
    newCancelButton.addEventListener('click', () => {
        modalOverlay.style.display = 'none';
    });
}


			
async function processMultiExport() {
    const packNameInput = document.getElementById('mcpackNameInput');
    const packName = packNameInput.value.trim() || `BiBuild Multi-Biome Pack`;
    
    const allPresets = getPresets();
    const presetsToProcess = [];

    // 1. Gather User Selections
    const mainCheckboxes = document.querySelectorAll('#multiExportPresetList input[type="checkbox"][id^="preset_main_"]');
    
    mainCheckboxes.forEach(cb => {
        if (cb.checked) {
            const name = cb.dataset.presetName;
            const serverCb = document.getElementById(`sub_server_${name}`);
            const clientCb = document.getElementById(`sub_client_${name}`);
            
            presetsToProcess.push({
                name: name,
                includeServer: serverCb ? serverCb.checked : false,
                includeClient: clientCb ? clientCb.checked : false
            });
        }
    });

    if (presetsToProcess.length === 0) {
        showSnackbar("Please select at least one preset to export.");
        return;
    }

    document.getElementById('multiExportModalOverlay').style.display = 'none';

    // 2. Setup MCADDON Structure
    const zip = new JSZip();
    
    // Generate UUIDs for Dependency Linking
    const bpHeaderUuid = generateUuidv4();
    const bpModuleUuid = generateUuidv4();
    const rpHeaderUuid = generateUuidv4();
    const rpModuleUuid = generateUuidv4();

    // Create Folders
    const bpFolder = zip.folder(packName.replace(/ /g, '_') + "_BP");
    const rpFolder = zip.folder(packName.replace(/ /g, '_') + "_RP");
    const bpBiomes = bpFolder.folder("biomes");
    const rpBiomes = rpFolder.folder("biomes"); // Note: Client biomes usually go in root or biomes, standard is biomes in RP too usually, or root if strictly defined. Let's put in 'biomes' to keep organized, bedrock allows nested.
    
    let addedServerCount = 0;
    let addedClientCount = 0;

    // 3. Process Files
    for (const item of presetsToProcess) {
        const presetData = allPresets[item.name];
        
        // Determine data structure (Legacy vs New)
        const serverData = presetData.server || (presetData['minecraft:biome'] ? presetData : null);
        const clientData = presetData.client || null;

        // --- Add Server File ---
        if (item.includeServer && serverData) {
            const id = serverData['minecraft:biome']?.description?.identifier;
            if (id) {
                const fileName = id.split(':')[1].replace(/[^a-z0-9._-]/g, '_') + '.biome.json';
                bpBiomes.file(fileName, JSON.stringify(serverData, null, 2));
                addedServerCount++;
            }
        }

        // --- Add Client File ---
        if (item.includeClient && clientData) {
            const id = clientData['minecraft:client_biome']?.description?.identifier;
            if (id) {
                const fileName = id.split(':')[1].replace(/[^a-z0-9._-]/g, '_') + '.client_biome.json';
                // Note: Client Biomes in RP usually work best when referencing the ID.
                // We put them in the 'biomes' folder of RP.
                rpBiomes.file(fileName, JSON.stringify(clientData, null, 2));
                addedClientCount++;
            }
        }
    }

    // 4. Generate Manifests
    const bpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} BP`,
            "description": `Contains ${addedServerCount} biomes. Generated by BiBuild.`,
            "uuid": bpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [{ "type": "data", "uuid": bpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": rpHeaderUuid, "version": [1, 0, 0] }]
    };

    const rpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} RP`,
            "description": `Contains ${addedClientCount} client biomes. Generated by BiBuild.`,
            "uuid": rpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [{ "type": "resources", "uuid": rpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": bpHeaderUuid, "version": [1, 0, 0] }]
    };

    bpFolder.file("manifest.json", JSON.stringify(bpManifest, null, 2));
    rpFolder.file("manifest.json", JSON.stringify(rpManifest, null, 2));

    // 5. Add Icons
    try {
        const response = await fetch('/icons/icon3.png');
        if (response.ok) {
            const blob = await response.blob();
            bpFolder.file("pack_icon.png", blob);
            rpFolder.file("pack_icon.png", blob);
        }
    } catch (e) { console.warn("Icon fetch failed", e); }

    // 6. Export .mcaddon
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName.replace(/ /g, '_')}.mcaddon`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showSnackbar(`Exported .mcaddon with ${addedServerCount} BP & ${addedClientCount} RP files!`);
    } catch (error) {
        showModal({title: 'Export Error', message: error.message, onConfirm: ()=>{}});
    }
}

			
			
			// --- Event Listeners ---
			
			document.addEventListener('DOMContentLoaded', () => {
			    _initializeForm();
			    updatePresetDropdown();
			    document.getElementById('savePresetButton').addEventListener('click', handleSavePreset);
			    document.getElementById('loadPresetButton').addEventListener('click', handleLoadPreset);
			    document.getElementById('deletePresetButton').addEventListener('click', handleDeletePreset);
			    document.getElementById('exportMultipleButton').addEventListener('click', handleExportMultiple);
			});
			
			// --- Your Original Script (Refactored for Integration) ---
			
			let generateFullBiomeJson;
			let _populateFormFromJson;
			let _initializeForm;
			let resetForm;
			
			(function() {
			    let dynamicElementCounter = 0;
			
			    const VANILLA_BIOMES = [
			        "minecraft:bamboo_jungle_hills", "minecraft:bamboo_jungle", "minecraft:beach",
			        "minecraft:birch_forest_hills_mutated", "minecraft:birch_forest_hills",
			        "minecraft:birch_forest_mutated", "minecraft:birch_forest", "minecraft:cherry_grove",
			        "minecraft:cold_beach", "minecraft:cold_ocean", "minecraft:cold_taiga_hills",
			        "minecraft:cold_taiga_mutated", "minecraft:cold_taiga", "minecraft:deep_cold_ocean",
			        "minecraft:deep_dark", "minecraft:deep_frozen_ocean", "minecraft:deep_lukewarm_ocean",
			        "minecraft:deep_ocean", "minecraft:deep_warm_ocean", "minecraft:desert_hills",
			        "minecraft:desert_mutated", "minecraft:desert", "minecraft:dripstone_caves",
			        "minecraft:extreme_hills_edge", "minecraft:extreme_hills_mutated",
			        "minecraft:extreme_hills_plus_trees_mutated", "minecraft:extreme_hills_plus_trees",
			        "minecraft:extreme_hills", "minecraft:flower_forest", "minecraft:forest_hills",
			        "minecraft:forest", "minecraft:frozen_ocean", "minecraft:frozen_peaks",
			        "minecraft:frozen_river", "minecraft:grove", "minecraft:ice_mountains",
			        "minecraft:ice_plains_spikes", "minecraft:ice_plains", "minecraft:jagged_peaks",
			        "minecraft:jungle_edge_mutated", "minecraft:jungle_edge", "minecraft:jungle_hills",
			        "minecraft:jungle_mutated", "minecraft:jungle", "minecraft:legacy_frozen_ocean",
			        "minecraft:lukewarm_ocean", "minecraft:lush_caves", "minecraft:mangrove_swamp",
			        "minecraft:meadow", "minecraft:mega_taiga_hills", "minecraft:mega_taiga",
			        "minecraft:mesa_bryce", "minecraft:mesa_plateau_mutated", "minecraft:mesa_plateau_stone_mutated",
			        "minecraft:mesa_plateau_stone", "minecraft:mesa_plateau", "minecraft:mesa",
			        "minecraft:mushroom_island_shore", "minecraft:mushroom_island", "minecraft:ocean",
			        "minecraft:pale_garden", "minecraft:plains", "minecraft:redwood_taiga_hills_mutated",
			        "minecraft:redwood_taiga_mutated", "minecraft:river", "minecraft:roofed_forest_mutated",
			        "minecraft:roofed_forest", "minecraft:savanna_mutated", "minecraft:savanna_plateau_mutated",
			        "minecraft:savanna_plateau", "minecraft:savanna", "minecraft:snowy_slopes",
			        "minecraft:stone_beach", "minecraft:stony_peaks", "minecraft:sunflower_plains",
			        "minecraft:swampland_mutated", "minecraft:swampland", "minecraft:taiga_hills",
			        "minecraft:taiga_mutated", "minecraft:taiga", "minecraft:warm_ocean"
			    ];
			
			    const BIOME_TAGS = [
			        "animal", "ash", "bamboo", "basalt_deltas", "beach", "bee_habitat", "birch", "caves", "cherry_grove",
			        "cold", "crimson_forest", "deep", "deep_dark", "desert", "dripstone_caves", "edge", "extreme_hills",
			        "flower_forest", "forest", "forest_generation", "frozen", "frozen_peaks", "grove", "has_structure_trail_ruins",
			        "hills", "ice", "ice_plains", "jagged_peaks", "jungle", "lukewarm", "lush_caves", "mangrove_swamp",
			        "meadow", "mega", "mesa", "monster", "mooshroom_island", "mountain", "mountains", "mutated", "nether",
			        "nether_wastes", "netherwart_forest", "no_legacy_worldgen", "ocean", "overworld", "overworld_generation",
			        "pale_garden", "plains", "plateau", "rare", "river", "roofed", "savanna", "shore", "snowy_slopes",
			        "soulsand_valley", "spawn_endermen", "spawn_few_piglins", "spawn_few_zombified_piglins", "spawn_ghast",
			        "spawn_magma_cubes", "spawn_many_magma_cubes", "spawn_piglin", "spawn_zombified_piglin", "stone",
			        "stony_peaks", "swamp", "taiga", "the_end", "underwater", "warm", "warped_forest"
			    ].sort();
			
			    function populateBiomeSelect(selectElementId) {
			        const select = document.getElementById(selectElementId);
			        select.innerHTML = '';
			        VANILLA_BIOMES.forEach(biome => {
			            const option = document.createElement('option');
			            option.value = biome;
			            option.textContent = biome;
			            select.appendChild(option);
			        });
			    }
			
			    function setupCollapsibleSections() {
			        document.querySelectorAll('.collapsible-header').forEach(header => {
			            const toggleCheckbox = header.querySelector('.component-toggle');
			            const content = document.getElementById(header.dataset.target);
			
			            if (toggleCheckbox) {
			                content.style.display = 'none';
			                header.classList.add('collapsed');
			                toggleRequiredFields(content, false);
			
			                header.addEventListener('click', (event) => {
			                    if (event.target.closest('.switch')) {
			                        event.stopPropagation();
			                        return;
			                    }
			                    toggleCheckbox.checked = !toggleCheckbox.checked;
			                    toggleCheckbox.dispatchEvent(new Event('change'));
			                });
			
			                toggleCheckbox.addEventListener('change', () => {
			                    content.style.display = toggleCheckbox.checked ? 'block' : 'none';
			                    header.classList.toggle('collapsed', !toggleCheckbox.checked);
			                    toggleRequiredFields(content, toggleCheckbox.checked);
			                });
			            }
			        });
			    }
			
			    function toggleRequiredFields(container, isEnabled) {
			        container.querySelectorAll('input, select, textarea').forEach(input => {
			            if (input.dataset.originalRequired === 'true') {
			                input.required = isEnabled;
			            }
			        });
			    }
			
			    function populateBiomeTags() {
			        const select = document.getElementById('biome_tags_select');
			        select.innerHTML = '';
			        BIOME_TAGS.forEach(tag => {
			            const option = document.createElement('option');
			            option.value = tag;
			            option.textContent = tag;
			            select.appendChild(option);
			        });
			    }
			
			    function createBlockSpecifierInputs(containerElement, prefix = '', initialData = null, labelText = 'Block Name', isNameRequired = true) {
			        let initialName = '';
			        let initialStates = null;
			        let areStatesEnabled = false;
			
			        if (typeof initialData === 'string') {
			            initialName = initialData;
			        } else if (typeof initialData === 'object' && initialData !== null) {
			            initialName = initialData.name || '';
			            if (initialData.states && Object.keys(initialData.states).length > 0) {
			                initialStates = initialData.states;
			                areStatesEnabled = true;
			            }
			        }
			
			        const blockNameId = `${prefix}name`;
			        const blockStatesId = `${prefix}states`;
			        const toggleStatesId = `toggle_${prefix}states`;
			        const statesGroupDivId = `${prefix}states_group`;
			        
			        containerElement.innerHTML = '';
			
			        const nameGroup = document.createElement('div');
			        nameGroup.classList.add('form-group');
			        nameGroup.innerHTML = `
			            <label for="${blockNameId}" ${isNameRequired ? 'class="required-field"' : ''}>${labelText}:</label>
			            <input type="text" id="${blockNameId}" placeholder="e.g., minecraft:dirt" value="${initialName}" ${isNameRequired ? 'required' : ''}>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">Name of the block. Example: "minecraft:stone"</span>
			            </div>`;
			        containerElement.appendChild(nameGroup);
			
			        const optionalStatesContainer = document.createElement('div');
			        optionalStatesContainer.classList.add('optional-input-container');
			        optionalStatesContainer.innerHTML = `
			            <div class="switch-container">
			                <label for="${toggleStatesId}">Enable States (Optional):</label>
			                <label class="switch">
			                    <input type="checkbox" id="${toggleStatesId}" class="optional-input-toggle" ${areStatesEnabled ? 'checked' : ''}>
			             <span class="slider"></span>       
			                </label>
			            </div>
			            <div id="${statesGroupDivId}" class="optional-input-content" style="display: ${areStatesEnabled ? 'block' : 'none'};">
			                <div class="form-group">
			                    <label for="${blockStatesId}">Block States (JSON Object):</label>
			                    <textarea id="${blockStatesId}" rows="2" placeholder='{"state_name": "value"}'>${initialStates ? JSON.stringify(initialStates, null, 2) : ''}</textarea>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Contains members named after each state, with boolean, integer, or string values. Example: {"direction": "north"}</span>
			                    </div>
			                </div>
			            </div>`;
			        containerElement.appendChild(optionalStatesContainer);
			        
			        const nameInput = containerElement.querySelector(`#${blockNameId}`);
			        if (nameInput && isNameRequired) nameInput.dataset.originalRequired = 'true';
			
			        const toggleCheckbox = containerElement.querySelector(`#${toggleStatesId}`);
			        const statesContent = containerElement.querySelector(`#${statesGroupDivId}`);
			        const statesTextarea = containerElement.querySelector(`#${blockStatesId}`);
			        
			        toggleCheckbox.addEventListener('change', () => {
			            statesContent.style.display = toggleCheckbox.checked ? 'block' : 'none';
			            if (!toggleCheckbox.checked) statesTextarea.value = '';
			        });
			    }
			    
			    function createBlockSpecifierGroup(uniqueIdPrefix, initialData = null) {
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        
			        let initialName = '';
			        let initialStates = null;
			        let areStatesEnabled = false;
			
			        if (typeof initialData === 'string') {
			            initialName = initialData;
			        } else if (typeof initialData === 'object' && initialData !== null) {
			            initialName = initialData.name || '';
			            if (initialData.states && Object.keys(initialData.states).length > 0) {
			                initialStates = initialData.states;
			                areStatesEnabled = true;
			            }
			        }
			
			        const toggleStatesId = `toggle_${uniqueIdPrefix}states`;
			        const statesGroupDivId = `${uniqueIdPrefix}states_group`;
			        div.innerHTML = `
			            <h4>Block Specifier</h4>
			            <div class="form-group">
			                <label for="${uniqueIdPrefix}name" class="required-field">Block Name:</label>
			                <input type="text" id="${uniqueIdPrefix}name" placeholder="e.g., minecraft:stone" value="${initialName}" required>
			            </div>
			            <div class="optional-input-container">
			                <div class="switch-container">
			                    <label for="${toggleStatesId}">Enable States (Optional):</label>
			                    <label class="switch">
			                        <input type="checkbox" id="${toggleStatesId}" class="optional-input-toggle" ${areStatesEnabled ? 'checked' : ''}>
			                        
			                  <span class="slider"></span>  </label>
			                </div>
			                <div id="${statesGroupDivId}" class="optional-input-content" style="display: ${areStatesEnabled ? 'block' : 'none'};">
			                    <div class="form-group">
			                        <label for="${uniqueIdPrefix}states">Block States (JSON Object):</label>
			                        <textarea id="${uniqueIdPrefix}states" rows="2" placeholder='{"key": "value"}'>${initialStates ? JSON.stringify(initialStates, null, 2) : ''}</textarea>
			                    </div>
			                </div>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Block Specifier
			            </button>`;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        
			        const nameInput = div.querySelector(`#${uniqueIdPrefix}name`);
			        nameInput.dataset.originalRequired = 'true';
			        
			        const toggleCheckbox = div.querySelector(`#${toggleStatesId}`);
			        const statesContent = div.querySelector(`#${statesGroupDivId}`);
			        const statesTextarea = div.querySelector(`#${uniqueIdPrefix}states`);
			        
			        toggleCheckbox.addEventListener('change', () => {
			            statesContent.style.display = toggleCheckbox.checked ? 'block' : 'none';
			            if (!toggleCheckbox.checked) statesTextarea.value = '';
			        });
			        
			        return div;
			    }
			
			
			    function addClimateCategoryEntry(category = '', weight = '') {
			        const container = document.getElementById('generate_for_climates_container');
			        const uniqueId = `climate_category_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        div.innerHTML = `
			            <div class="form-group">
			                <label for="${uniqueId}category" class="required-field">Climate Category:</label>
			                <select id="${uniqueId}category" required>
			                    <option value="">--Select Category--</option>
			                    <option value="medium">medium</option>
			                    <option value="warm">warm</option>
			                    <option value="lukewarm">lukewarm</option>
			                    <option value="cold">cold</option>
			                    <option value="frozen">frozen</option>
			                </select>
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}weight" class="required-field">Weight (Integer, Positive):</label>
			                <input type="number" min="1" step="1" id="${uniqueId}weight" placeholder="e.g., 1" required>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Category
			            </button>`;
			        container.appendChild(div);
			        div.querySelector(`#${uniqueId}category`).value = category;
			        div.querySelector(`#${uniqueId}weight`).value = weight;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');
			            // --- ADDED: Initialize the new multi-select UI immediately ---
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }
    // -------------------------------------------------------------
			        return div;
			    }
			
			    function addWeightedBiomeEntry(containerId, biomeName = '', weight = '') {
			        const container = document.getElementById(containerId);
			        const uniqueId = `${containerId.replace('_container', '')}_entry_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('dynamic-item', 'form-group');
			        div.innerHTML = `
			            <label for="${uniqueId}biome" class="required-field">Biome Name:</label>
			            <select id="${uniqueId}biome" required></select>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">Select a biome name.</span>
			            </div>
			            <label for="${uniqueId}weight" class="required-field">Weight (Integer, Positive):</label>
			            <input type="number" min="1" step="1" id="${uniqueId}weight" placeholder="e.g., 1" value="${weight}" required>
			            <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                <span class="tooltiptext">The weight of this biome relative to others in the list.</span>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove
			            </button>`;
			        container.appendChild(div);
			        const biomeSelect = div.querySelector(`#${uniqueId}biome`);
			        VANILLA_BIOMES.forEach(biome => {
			            const option = document.createElement('option');
			            option.value = biome;
			            option.textContent = biome;
			            biomeSelect.appendChild(option);
			        });
			        biomeSelect.value = biomeName;
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');
			            // --- ADDED: Initialize the new multi-select UI immediately ---
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }
    // -------------------------------------------------------------
			        return div;
			    }
			
			    function addMaterialAdjustmentEntry(adjustmentData = {}) {
			        const { noise_range = [], height_range = [], noise_frequency_scale = '', materials = {} } = adjustmentData;
			        const container = document.getElementById('material_adjustments_container');
			        const uniqueId = `material_adj_${Date.now()}_`;
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			        div.innerHTML = `
			            <h4>Material Adjustment</h4>
			            <div class="form-group">
			                <label>Noise Range (Min, Max - Array of 2 Floats):</label>
			                <input type="number" step="0.01" id="${uniqueId}noise_min" placeholder="e.g., 0.2" value="${noise_range[0] || ''}">
			                <input type="number" step="0.01" id="${uniqueId}noise_max" placeholder="e.g., 0.5" value="${noise_range[1] || ''}">
			            </div>
			            <div class="form-group">
			                <label>Height Range (Min, Max - Array of 2 Molang expressions):</label>
			                <input type="text" id="${uniqueId}height_min" placeholder="e.g., 0" value="${height_range[0] || ''}">
			                <input type="text" id="${uniqueId}height_max" placeholder="e.g., 100" value="${height_range[1] || ''}">
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}noise_freq_scale">Noise Frequency Scale (Float):</label>
			                <input type="number" step="0.01" id="${uniqueId}noise_freq_scale" placeholder="e.g., 1.0" value="${noise_frequency_scale}">
			            </div>
			            <h5>Materials</h5>
			            <div class="sub-group" id="${uniqueId}materials_container">
			                <!-- Material specifiers will be added here -->
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Adjustment
			            </button>`;
			        container.appendChild(div);
			
			        const materialsContainer = div.querySelector(`#${uniqueId}materials_container`);
			        const materialTypes = ['top_material', 'foundation_material', 'mid_material', 'sea_floor_material', 'sea_material'];
			
			        materialTypes.forEach(matType => {
			            const matData = materials[matType];
			            const matContainerId = `${uniqueId}${matType}_container`;
			            const matGroupId = `${uniqueId}${matType}_group`;
			            const matEnableId = `${uniqueId}enable_${matType}`;
			            
			            const optionalContainer = document.createElement('div');
			            optionalContainer.className = 'optional-input-container';
			            optionalContainer.innerHTML = `
			                <div class="switch-container">
			                    <label for="${matEnableId}">Enable ${matType.replace(/_/g, ' ')} (Optional):</label>
			                    <label class="switch">
			                        <input type="checkbox" id="${matEnableId}" class="optional-input-toggle" ${matData ? 'checked' : ''}>
			                        
			           <span class="slider"></span>         </label>
			                </div>
			                <div id="${matGroupId}" class="optional-input-content" style="display: ${matData ? 'block' : 'none'};">
			                    <div class="form-group" id="${matContainerId}"></div>
			                </div>`;
			            materialsContainer.appendChild(optionalContainer);
			            
			            const blockSpecContainer = div.querySelector(`#${matContainerId}`);
			            createBlockSpecifierInputs(blockSpecContainer, `${uniqueId}${matType}_`, matData, `${matType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (Block Specifier)`, false);
			
			            const enableToggle = div.querySelector(`#${matEnableId}`);
			            const contentGroup = div.querySelector(`#${matGroupId}`);
			            enableToggle.addEventListener('change', () => {
			                contentGroup.style.display = enableToggle.checked ? 'block' : 'none';
			            });
			        });
			
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        return div;
			    }
			    
			    function addReplacementEntry(replacementData = {}) {
			        const {
			            dimension = 'minecraft:overworld',
			            amount = '',
			            noise_frequency_scale = '',
			            targets = []
			        } = replacementData;
			
			        const container = document.getElementById('replacements_list_container');
			        const uniqueId = `replacement_${Date.now()}_${dynamicElementCounter++}_`;
			        const div = document.createElement('div');
			        div.classList.add('sub-group', 'dynamic-item');
			
			        let optionsHtml = '';
			        VANILLA_BIOMES.forEach(biome => {
			            const isSelected = targets.includes(biome);
			            optionsHtml += `<option value="${biome}" ${isSelected ? 'selected' : ''}>${biome}</option>`;
			        });
			
			        div.innerHTML = `
			            <h4>Replacement Rule</h4>
			            <div class="form-group">
			                <label for="${uniqueId}dimension" class="required-field">Dimension (String):</label>
			                <input type="text" id="${uniqueId}dimension" value="${dimension}" required>
			                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                    <span class="tooltiptext">Dimension in which this replacement can happen. e.g., 'minecraft:overworld'.</span>
			                </div>
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}amount" class="required-field">Amount (Float, 0.0 - 1.0]:</label>
			                <input type="number" step="any" min="0.001" max="1.0" id="${uniqueId}amount" placeholder="e.g., 0.7" value="${amount}" required>
			                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                    <span class="tooltiptext">Noise value, similar to a percentage. Must be in the range (0.0, 1.0].</span>
			                </div>
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}noise_freq_scale" class="required-field">Noise Frequency Scale (Float, 0.0 - 100.0]:</label>
			                <input type="number" step="any" min="0.001" max="100.0" id="${uniqueId}noise_freq_scale" placeholder="e.g., 42" value="${noise_frequency_scale}" required>
			                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                    <span class="tooltiptext">Scaling value for replacement frequency. Must be in the range (0.0, 100.0].</span>
			                </div>
			            </div>
			            <div class="form-group">
			                <label for="${uniqueId}targets_select" class="required-field">Targets (Multi-select Biome Names):</label>
			                <select id="${uniqueId}targets_select" multiple size="8" required>
			                    ${optionsHtml}
			                </select>
			                <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                    <span class="tooltiptext">Biomes that are going to be replaced.</span>
			                </div>
			            </div>
			            <button type="button" class="button remove-button">
			                <span class="material-symbols-rounded">remove</span>
			                Remove Replacement
			            </button>
			        `;
			        container.appendChild(div);
			
			        div.querySelector('.remove-button').onclick = (e) => e.target.closest('.dynamic-item').remove();
			        div.querySelectorAll('input[required], select[required]').forEach(input => input.dataset.originalRequired = 'true');
			            // --- ADDED: Initialize the new multi-select UI immediately ---
    if (typeof initMultiSelects === 'function') {
        initMultiSelects();
    }
    // -------------------------------------------------------------
			        return div;
			    }
			
			    function getBlockSpecifierFromGroup(containerElement) {
			        const nameInput = containerElement.querySelector('input[id$="name"]');
			        const statesTextarea = containerElement.querySelector('textarea[id$="states"]');
			        const toggleStatesCheckbox = containerElement.querySelector('input[id^="toggle_"][id$="states"]');
			
			        const name = nameInput?.value.trim();
			        if (!name) return null;
			
			        if (!toggleStatesCheckbox || !toggleStatesCheckbox.checked) {
			            return name; // Return as a simple string
			        }
			
			        const blockSpec = { name: name };
			        if (statesTextarea?.value.trim()) {
			            try {
			                const states = JSON.parse(statesTextarea.value.trim());
			                if (Object.keys(states).length > 0) {
			                    blockSpec.states = states;
			                }
			            } catch (e) {
			                showModal({title: 'JSON Parse Error', message: `Invalid JSON for states in block specifier "${name}".`, onConfirm: ()=>{}});
			                throw e;
			            }
			        }
			        
			        // If states are enabled but empty, just return the object with the name.
			        return blockSpec;
			    }
			
			    const appendSingleBlockSpecifierInput = (parentContainer, inputName, initialData = null, isRequired = true) => {
			        const div = document.createElement('div');
			        div.classList.add('form-group');
			        parentContainer.appendChild(div);
			        const formattedLabel = `${inputName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} (Block Specifier)`;
			        createBlockSpecifierInputs(div, `sb_${inputName}_`, initialData, formattedLabel, isRequired);
			    };
			
			    const appendMultiBlockSpecifierSection = (parentContainer, materialName, initialMaterials = []) => {
			        const uniqueIdPrefix = 'sb_';
			        const sectionDiv = document.createElement('div');
			        sectionDiv.classList.add('form-group');
			        sectionDiv.innerHTML = `
			            <label class="required-field">${materialName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</label>
			            <button type="button" class="button add-button" id="add_${materialName}_button">
			                <span class="material-symbols-rounded">add</span>
			                Add Block Specifier
			            </button>
			            <div id="${uniqueIdPrefix}${materialName}_list_container"></div>`;
			        parentContainer.appendChild(sectionDiv);
			        const listContainer = document.getElementById(`${uniqueIdPrefix}${materialName}_list_container`);
			        initialMaterials.forEach(material => {
			            dynamicElementCounter++;
			            const newBlockSpecifierGroup = createBlockSpecifierGroup(`${uniqueIdPrefix}${materialName}_${Date.now()}_${dynamicElementCounter}`, material);
			            listContainer.appendChild(newBlockSpecifierGroup);
			        });
			        document.getElementById(`add_${materialName}_button`).addEventListener('click', () => {
			            dynamicElementCounter++;
			            const newBlockSpecifierGroup = createBlockSpecifierGroup(`${uniqueIdPrefix}${materialName}_${Date.now()}_${dynamicElementCounter}`);
			            listContainer.appendChild(newBlockSpecifierGroup);
			        });
			    };
			
			    function renderSurfaceBuilderFields(builderType, builderData = {}) {
			        const container = document.getElementById('surface_builder_dynamic_fields');
			        container.innerHTML = '';
			        if (!builderType) return;
			
			        switch (builderType) {
			            case "minecraft:overworld":
			            case "minecraft:frozen_ocean":
			            case "minecraft:swamp":
			                const seaFloorDepthDiv = document.createElement('div');
			                seaFloorDepthDiv.classList.add('form-group');
			                seaFloorDepthDiv.innerHTML = `
			                    <label for="sb_sea_floor_depth" class="required-field">Sea Floor Depth (Integer):</label>
			                    <input type="number" step="1" id="sb_sea_floor_depth" value="${builderData.sea_floor_depth || ''}" required>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Controls how deep below the world water level the floor should occur.</span>
			                    </div>`;
			                container.appendChild(seaFloorDepthDiv);
			                appendSingleBlockSpecifierInput(container, 'sea_floor_material', builderData.sea_floor_material);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'mid_material', builderData.mid_material);
			                appendSingleBlockSpecifierInput(container, 'top_material', builderData.top_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			
			                 if (builderType === "minecraft:swamp") {
			                    const maxPuddleDepthDiv = document.createElement('div');
			                    maxPuddleDepthDiv.classList.add('form-group');
			                    maxPuddleDepthDiv.innerHTML = `
			                        <label for="sb_max_puddle_depth_below_sea_level" class="required-field">Max Puddle Depth Below Sea Level (Integer):</label>
			                        <input type="number" step="1" min="0" max="127" id="sb_max_puddle_depth_below_sea_level" value="${builderData.max_puddle_depth_below_sea_level || ''}" required>
			                        <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                            <span class="tooltiptext">Controls the depth at which surface level blocks can be replaced with water for puddles.</span>
			                        </div>`;
			                    container.appendChild(maxPuddleDepthDiv);
			                }
			                break;
			            case "minecraft:mesa":
			                const mesaSeaFloorDepthDiv = document.createElement('div');
			                mesaSeaFloorDepthDiv.classList.add('form-group');
			                mesaSeaFloorDepthDiv.innerHTML = `
			                    <label for="sb_sea_floor_depth" class="required-field">Sea Floor Depth (Integer):</label>
			                    <input type="number" step="1" id="sb_sea_floor_depth" value="${builderData.sea_floor_depth || ''}" required>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Controls how deep below the world water level the floor should occur.</span>
			                    </div>`;
			                container.appendChild(mesaSeaFloorDepthDiv);
			
			                appendSingleBlockSpecifierInput(container, 'sea_floor_material', builderData.sea_floor_material);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'mid_material', builderData.mid_material);
			                appendSingleBlockSpecifierInput(container, 'top_material', builderData.top_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			
			                const brycePillarsDiv = document.createElement('div');
			                brycePillarsDiv.classList.add('switch-container');
			                brycePillarsDiv.innerHTML = `
			                    <label for="sb_bryce_pillars" class="required-field">Bryce Pillars:</label>
			                    <label class="switch">
			                        <input type="checkbox" id="sb_bryce_pillars" ${builderData.bryce_pillars ? 'checked' : ''}>
			                        
			           <span class="slider"></span>         </label>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Whether the mesa generates with pillars.</span>
			                    </div>`;
			                container.appendChild(brycePillarsDiv);
			
			                appendSingleBlockSpecifierInput(container, 'clay_material', builderData.clay_material);
			                appendSingleBlockSpecifierInput(container, 'hard_clay_material', builderData.hard_clay_material);
			
			                const hasForestDiv = document.createElement('div');
			                hasForestDiv.classList.add('switch-container');
			                hasForestDiv.innerHTML = `
			                    <label for="sb_has_forest" class="required-field">Has Forest:</label>
			                    <label class="switch">
			                        <input type="checkbox" id="sb_has_forest" ${builderData.has_forest ? 'checked' : ''}>
			          <span class="slider"></span>              
			                    </label>
			                    <div class="tooltip"><span class="material-symbols-rounded">question_mark</span>
			                        <span class="tooltiptext">Places coarse dirt and grass at high altitudes.</span>
			                    </div>`;
			                container.appendChild(hasForestDiv);
			                break;
			            case "minecraft:capped":
			                appendSingleBlockSpecifierInput(container, 'beach_material', builderData.beach_material, false); // Beach is optional
			                appendMultiBlockSpecifierSection(container, 'ceiling_materials', builderData.ceiling_materials || []);
			                appendMultiBlockSpecifierSection(container, 'floor_materials', builderData.floor_materials || []);
			                appendSingleBlockSpecifierInput(container, 'foundation_material', builderData.foundation_material);
			                appendSingleBlockSpecifierInput(container, 'sea_material', builderData.sea_material);
			                break;
			        }
			        container.querySelectorAll('input[required], select[required], textarea[required]').forEach(input => input.dataset.originalRequired = 'true');
			    }
			
			    function addCustomTag(tagValue = '') {
			        const customTagInput = document.getElementById('custom_tag_input');
			        const tag = tagValue || customTagInput.value.trim().toLowerCase();
			        if (!tag) {
			            showModal({title: 'Input Error', message: "Custom tag cannot be empty.", onConfirm: ()=>{}});
			            return;
			        }
			        if (!/^[a-z0-9._]+$/.test(tag)) {
			            showModal({title: 'Input Error', message: "Custom tags should only contain lowercase alphanumeric characters, periods, and underscores.", onConfirm: ()=>{}});
			            return;
			        }
			        const predefinedTags = Array.from(document.getElementById('biome_tags_select').options).map(opt => opt.value);
			        if (predefinedTags.includes(tag) || customTags.includes(tag)) {
			            if (!tagValue) showModal({title: 'Duplicate Tag', message: `Tag "${tag}" already exists.`, onConfirm: ()=>{}});
			            return;
			        }
			        customTags.push(tag);
			        customTags.sort();
			        renderCustomTags();
			        if (!tagValue) customTagInput.value = '';
			    }
			
			    function renderCustomTags() {
			        const displayContainer = document.getElementById('custom_tags_display');
			        displayContainer.innerHTML = '';
			        customTags.forEach(tag => {
			            const tagItem = document.createElement('span');
			            tagItem.classList.add('tag-item');
			            tagItem.textContent = tag;
			            const removeButton = document.createElement('button');
			            removeButton.classList.add('remove-tag-button');
			            removeButton.innerHTML = '&times;';
			            removeButton.title = `Remove ${tag}`;
			            removeButton.onclick = () => removeCustomTag(tag);
			            tagItem.appendChild(removeButton);
			            displayContainer.appendChild(tagItem);
			        });
			    }
			
			    function removeCustomTag(tagToRemove) {
			        customTags = customTags.filter(tag => tag !== tagToRemove);
			        renderCustomTags();
			    }
			
			    function hexToRgb(hex) {
			        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
			        hex = hex.replace(shorthandRegex, function(m, r, g, b) { return r + r + g + g + b + b; });
			        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			        return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
			    }
			
			    function rgbToHex(r, g, b) {
			        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
			    }
			
			    function parseColorInput(value) {
			        value = value.trim();
			        if (!value) return null;
			        let rgb = hexToRgb(value);
			        if (rgb) return rgbToHex(rgb.r, rgb.g, rgb.b);
			        const rgbMatch = value.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i);
			        if (rgbMatch) {
			            const r = parseInt(rgbMatch[1]), g = parseInt(rgbMatch[2]), b = parseInt(rgbMatch[3]);
			            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) return rgbToHex(r, g, b);
			        }
			        return null;
			    }
			
			    function updateColorInputUI(textInput, colorPicker, defaultColor = '#000000') {
			        const applyColor = (color) => { colorPicker.value = color || '#000000'; };
			        const initialParsedColor = parseColorInput(textInput.value);
			        applyColor(initialParsedColor || defaultColor);
			        textInput.addEventListener('input', () => applyColor(parseColorInput(textInput.value)));
			        textInput.addEventListener('blur', () => {
			            const parsedColor = parseColorInput(textInput.value);
			            if (parsedColor) {
			                textInput.value = parsedColor;
			            } else if (textInput.value.trim() !== '') {
			                textInput.value = defaultColor;
			                applyColor(defaultColor);
			            } else {
			                applyColor(null);
			            }
			        });
			        colorPicker.addEventListener('input', () => { textInput.value = colorPicker.value.toUpperCase(); });
			    }
			
    resetForm = function() {
        // Reset Server Form
        document.getElementById('biomeForm').reset();
        
        // Reset Client Form
        document.getElementById('clientBiomeForm').reset();
        
        // Reset Main Client Toggle
        const clientToggle = document.getElementById('enable_clientbiomes');
        clientToggle.checked = false;
        document.getElementById('hidden-container').style.display = 'none';
        // --- ADD THIS BLOCK ---
        const unusedToggle = document.getElementById('show_unused_components');
        const unusedWrapper = document.getElementById('unused_components_wrapper');
        if (unusedToggle) unusedToggle.checked = false;
        if (unusedWrapper) unusedWrapper.style.display = 'none';

        // Reset All Collapsible Sections (Server & Client)
        document.querySelectorAll('.component-toggle').forEach(toggle => {
            toggle.checked = false;
            const header = toggle.closest('.collapsible-header');
            const content = document.getElementById(header.dataset.target);
            if (content) {
                content.style.display = 'none';
                toggleRequiredFields(content, false);
            }
            if (header) header.classList.add('collapsed');
        });

        // Clear Dynamic Server Fields
        document.getElementById('generate_for_climates_container').querySelectorAll('.dynamic-item').forEach(item => item.remove());
        document.getElementById('material_adjustments_container').querySelectorAll('.dynamic-item').forEach(item => item.remove());
        document.getElementById('replacements_list_container').innerHTML = '<h4>Replacements</h4>';
        document.getElementById('surface_builder_dynamic_fields').innerHTML = '';
        
        // Reset Selects
        document.querySelectorAll('select[multiple]').forEach(select => Array.from(select.options).forEach(option => option.selected = false));
        
        // Reset Tags
        customTags = [];
        renderCustomTags();
        
        // Reset Specific Server UI Groups
        document.getElementById('height_noise_type_radio').checked = false;
        document.getElementById('height_noise_params_radio').checked = false;
        document.getElementById('height_noise_type_group').style.display = 'none';
        document.getElementById('noise_type_select').removeAttribute('required');
        document.getElementById('noise_params_depth').removeAttribute('required');
        document.getElementById('noise_params_scale').removeAttribute('required');
        
        document.getElementById('enable_steep_material_adjustment').checked = false;
        document.getElementById('steep_material_adjustment_group').style.display = 'none';
        createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
        
        document.getElementById('steep_north_slopes').checked = false;
        document.getElementById('steep_south_slopes').checked = false;
        document.getElementById('steep_east_slopes').checked = false;
        document.getElementById('steep_west_slopes').checked = false;
        
        document.getElementById('enable_map_tints_foliage').checked = false;
        document.getElementById('map_tints_foliage_group').style.display = 'none';
        document.getElementById('map_tints_foliage_color_input').value = '#6A7039';
        document.getElementById('map_tints_foliage_color_picker').value = '#6A7039';
        
        document.getElementById('grass_tint_type_noise').checked = true;
        document.getElementById('grass_custom_tint_group').style.display = 'none';
        document.getElementById('grass_custom_tint_color_input').removeAttribute('required');
        document.getElementById('grass_custom_tint_color_input').value = '#B6DB61';
        document.getElementById('grass_custom_tint_color_picker').value = '#B6DB61';
        
        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
            document.getElementById(`${transformType}_transform_type_simple`).checked = true;
            document.getElementById(`${transformType}_transform_type_weighted`).checked = false;
            document.getElementById(`${transformType}_transformation_simple_group`).style.display = 'block';
            document.getElementById(`${transformType}_transformation_weighted_group`).style.display = 'none';
            document.getElementById(`${transformType}_weighted_biomes_container`).innerHTML = '';
            populateBiomeSelect(`${transformType}_transformation_select`);
        });

        // Clear Outputs
        document.getElementById('jsonOutput').textContent = '';
        document.getElementById('outputJson').textContent = '';
        
        // Hide Outputs Sections
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'none';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
        
        const clientContent = document.getElementById('client-biome-content');
        clientContent.style.display = 'none';
        clientContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
    }

			
			    _populateFormFromJson = function(jsonData) {
			        try {
			            const biomeData = jsonData['minecraft:biome'];
			            if (!biomeData) throw new Error("Invalid biome JSON: 'minecraft:biome' key not found.");
			            document.getElementById('format_version').value = jsonData.format_version || '';
			            document.getElementById('identifier').value = biomeData.description?.identifier || '';
			            const components = biomeData.components || {};
			            for (const componentName in components) {
			                const componentData = components[componentName];
			                const componentId = componentName.replace('minecraft:', '');
			                const enableToggle = document.getElementById(`enable_${componentId}`);
			                const contentDiv = document.getElementById(`${componentId}-content`);
			                const headerElement = document.querySelector(`.collapsible-header[data-target="${componentId}-content"]`);
			                if (enableToggle) enableToggle.checked = true;
			                if (contentDiv) {
			                    contentDiv.style.display = 'block';
			                    if (headerElement) headerElement.classList.remove('collapsed');
			                    toggleRequiredFields(contentDiv, true);
			                }
			                switch (componentName) {
			                    case 'minecraft:climate':
			                        if (typeof componentData.temperature === 'number') document.getElementById('climate_temperature').value = componentData.temperature;
			                        if (typeof componentData.downfall === 'number') document.getElementById('climate_downfall').value = componentData.downfall;
			                        if (Array.isArray(componentData.snow_accumulation)) {
			                            document.getElementById('climate_snow_acc_min').value = componentData.snow_accumulation[0];
			                            document.getElementById('climate_snow_acc_max').value = componentData.snow_accumulation[1];
			                        }
			                        break;
			                    case 'minecraft:creature_spawn_probability':
			                        if (typeof componentData.probability === 'number') document.getElementById('creature_spawn_probability_value').value = componentData.probability;
			                        break;
			                    case 'minecraft:humidity':
			                        if (typeof componentData.is_humid === 'boolean') document.getElementById('humidity_is_humid').checked = componentData.is_humid;
			                        break;
			                    case 'minecraft:map_tints':
			                        const enableFoliageToggle = document.getElementById('enable_map_tints_foliage');
			                        const foliageGroup = document.getElementById('map_tints_foliage_group');
			                        const foliageInput = document.getElementById('map_tints_foliage_color_input');
			                        const foliagePicker = document.getElementById('map_tints_foliage_color_picker');
			                        if (componentData.foliage) {
			                            enableFoliageToggle.checked = true;
			                            foliageGroup.style.display = 'block';
			                            foliageInput.value = componentData.foliage;
			                            foliagePicker.value = componentData.foliage;
			                        } else {
			                            enableFoliageToggle.checked = false;
			                            foliageGroup.style.display = 'none';
			                        }
			                        const grassCustomTintGroup = document.getElementById('grass_custom_tint_group');
			                        const grassCustomTintColorInput = document.getElementById('grass_custom_tint_color_input');
			                        const grassCustomTintColorPicker = document.getElementById('grass_custom_tint_color_picker');
			                        if (componentData.grass) {
			                            if (componentData.grass.type === 'tint' && componentData.grass.tint) {
			                                document.getElementById('grass_tint_type_custom').checked = true;
			                                grassCustomTintGroup.style.display = 'block';
			                                grassCustomTintColorInput.value = componentData.grass.tint;
			                                grassCustomTintColorInput.setAttribute('required', true);
			                                grassCustomTintColorPicker.value = componentData.grass.tint;
			                            } else {
			                                document.getElementById('grass_tint_type_noise').checked = true;
			                                grassCustomTintGroup.style.display = 'none';
			                                grassCustomTintColorInput.removeAttribute('required');
			                            }
			                        }
			                        break;
			                    case 'minecraft:mountain_parameters':
			                        if (componentData.top_slide && typeof componentData.top_slide.enabled === 'boolean') {
			                            document.getElementById('top_slide_enabled').checked = componentData.top_slide.enabled;
			                        }
			                        if (componentData.steep_material_adjustment) {
			                            document.getElementById('enable_steep_material_adjustment').checked = true;
			                            document.getElementById('steep_material_adjustment_group').style.display = 'block';
			                            const adj = componentData.steep_material_adjustment;
			                            createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', adj.material, 'Steep Material (Block Specifier)', false);
			                            if (typeof adj.north_slopes === 'boolean') document.getElementById('steep_north_slopes').checked = adj.north_slopes;
			                            if (typeof adj.south_slopes === 'boolean') document.getElementById('steep_south_slopes').checked = adj.south_slopes;
			                            if (typeof adj.east_slopes === 'boolean') document.getElementById('steep_east_slopes').checked = adj.east_slopes;
			                            if (typeof adj.west_slopes === 'boolean') document.getElementById('steep_west_slopes').checked = adj.west_slopes;
			                        } else {
			                            document.getElementById('enable_steep_material_adjustment').checked = false;
			                            document.getElementById('steep_material_adjustment_group').style.display = 'none';
			                            createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
			                        }
			                        break;
			                    case 'minecraft:multinoise_generation_rules':
			                        if (typeof componentData.target_altitude === 'number') document.getElementById('multinoise_target_altitude').value = componentData.target_altitude;
			                        if (typeof componentData.target_humidity === 'number') document.getElementById('multinoise_target_humidity').value = componentData.target_humidity;
			                        if (typeof componentData.target_temperature === 'number') document.getElementById('multinoise_target_temperature').value = componentData.target_temperature;
			                        if (typeof componentData.weirdness === 'number') document.getElementById('multinoise_target_weirdness').value = componentData.weirdness;
			                        if (typeof componentData.weight === 'number') document.getElementById('multinoise_weight').value = componentData.weight;
			                        break;
			                    case 'minecraft:overworld_generation_rules':
			                        if (Array.isArray(componentData.generate_for_climates)) {
			                            componentData.generate_for_climates.forEach(climate => {
			                                if (Array.isArray(climate) && climate.length === 2) addClimateCategoryEntry(climate[0], climate[1]);
			                            });
			                        }
			                        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
			                            const transformData = componentData[`${transformType}_transformation`];
			                            const simpleRadio = document.getElementById(`${transformType}_transform_type_simple`);
			                            const weightedRadio = document.getElementById(`${transformType}_transform_type_weighted`);
			                            const simpleGroup = document.getElementById(`${transformType}_transformation_simple_group`);
			                            const weightedGroup = document.getElementById(`${transformType}_transformation_weighted_group`);
			                            const weightedContainer = document.getElementById(`${transformType}_weighted_biomes_container`);
			                            weightedContainer.innerHTML = '';
			                            if (typeof transformData === 'string') {
			                                simpleRadio.checked = true;
			                                const selectElement = document.getElementById(`${transformType}_transformation_select`);
			                                const option = selectElement.querySelector(`option[value="${transformData}"]`);
			                                if (option) option.selected = true;
			                            } else if (Array.isArray(transformData)) {
			                                const isWeighted = transformData.some(item => Array.isArray(item));
			                                if (isWeighted) {
			                                    weightedRadio.checked = true;
			                                    transformData.forEach(item => {
			                                        if (Array.isArray(item) && item.length === 2) {
			                                            addWeightedBiomeEntry(`${transformType}_weighted_biomes_container`, item[0], item[1]);
			                                        } else if (typeof item === 'string') {
			                                            addWeightedBiomeEntry(`${transformType}_weighted_biomes_container`, item, 1);
			                                        }
			                                    });
			                                } else {
			                                    simpleRadio.checked = true;
			                                    const selectElement = document.getElementById(`${transformType}_transformation_select`);
			                                    transformData.forEach(biomeId => {
			                                        const option = selectElement.querySelector(`option[value="${biomeId}"]`);
			                                        if (option) option.selected = true;
			                                    });
			                                }
			                            }
			                            simpleGroup.style.display = simpleRadio.checked ? 'block' : 'none';
			                            weightedGroup.style.display = weightedRadio.checked ? 'block' : 'none';
			                            toggleRequiredFields(simpleGroup, simpleRadio.checked);
			                            toggleRequiredFields(weightedGroup, weightedRadio.checked);
			                        });
			                        break;
			                    case 'minecraft:overworld_height':
			                        if (componentData.noise_type) {
			                            document.getElementById('height_noise_type_radio').checked = true;
			                            document.getElementById('height_noise_type_group').style.display = 'block';
			                            document.getElementById('noise_type_select').value = componentData.noise_type;
			                            toggleRequiredFields(document.getElementById('height_noise_type_group'), true);
			                        } else if (Array.isArray(componentData.noise_params) && componentData.noise_params.length === 2) {
			                            document.getElementById('height_noise_params_radio').checked = true;
			                            document.getElementById('height_noise_params_group').style.display = 'block';
			                            document.getElementById('noise_params_depth').value = componentData.noise_params[0];
			                            document.getElementById('noise_params_scale').value = componentData.noise_params[1];
			                            toggleRequiredFields(document.getElementById('height_noise_params_group'), true);
			                        }
			                        break;
			                    case 'minecraft:partially_frozen':
			                        break;
			                    case 'minecraft:replace_biomes':
			                        if (Array.isArray(componentData.replacements)) {
			                            componentData.replacements.forEach(replacement => {
			                                addReplacementEntry(replacement);
			                            });
			                        }
			                        break;
			                        break;
			                    case 'minecraft:surface_builder':
			                        if (componentData.builder && componentData.builder.type) {
			                            document.getElementById('surface_builder_type_select').value = componentData.builder.type;
			                            renderSurfaceBuilderFields(componentData.builder.type, componentData.builder);
			                        }
			                        break;
			                    case 'minecraft:surface_material_adjustments':
			                        if (Array.isArray(componentData.adjustments)) {
			                            componentData.adjustments.forEach(adjustment => addMaterialAdjustmentEntry(adjustment));
			                        }
			                        break;
			                    case 'minecraft:tags':
			                        if (Array.isArray(componentData.tags)) {
			                            customTags = [];
			                            const predefinedSelect = document.getElementById('biome_tags_select');
			                            componentData.tags.forEach(tag => {
			                                const option = predefinedSelect.querySelector(`option[value="${tag}"]`);
			                                if (option) {
			                                    option.selected = true;
			                                } else {
			                                    addCustomTag(tag);
			                                }
			                            });
			                            renderCustomTags();
			                        }
			                        break;
			                }
			            }
			        } catch (error) {
			            showModal({title: 'Import Error', message: `Failed to load biome JSON: ${error.message}`, onConfirm: ()=>{}});
			            console.error("Import Error:", error);
			            resetForm();
			        }
			    }
			
			    generateFullBiomeJson = function() {
			        const biomeJson = {};
			        biomeJson.format_version = document.getElementById('format_version').value.trim();
			        if (!biomeJson.format_version) throw new Error("Format Version is required.");
			        const identifier = document.getElementById('identifier').value.trim().toLowerCase();
			        if (!identifier) throw new Error("Biome Identifier is required.");
			        // --- ADDED VALIDATION HERE ---
// Regex pattern: namespace:name (lowercase, numbers, dots, underscores, %, +, -)
const idPattern = /^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/;
if (!idPattern.test(identifier)) {
    throw new Error("Identifier invalid. Use namespace:biome_name pattern (lowercase).");
}
			        biomeJson['minecraft:biome'] = {
			            description: { identifier: identifier },
			            components: {}
			        };
			        const components = biomeJson['minecraft:biome'].components;
			        if (document.getElementById('enable_climate').checked) {
			            const climate = {};
			            const temperature = parseFloat(document.getElementById('climate_temperature').value);
			            if (!isNaN(temperature)) climate.temperature = temperature;
			            const downfall = parseFloat(document.getElementById('climate_downfall').value);
			            if (!isNaN(downfall)) climate.downfall = downfall;
			            const snowAccMin = parseFloat(document.getElementById('climate_snow_acc_min').value);
			            const snowAccMax = parseFloat(document.getElementById('climate_snow_acc_max').value);
			            if (!isNaN(snowAccMin) && !isNaN(snowAccMax)) climate.snow_accumulation = [snowAccMin, snowAccMax];
			            if (Object.keys(climate).length > 0) components['minecraft:climate'] = climate;
			        }
			        if (document.getElementById('enable_creature_spawn_probability').checked) {
			            const probability = parseFloat(document.getElementById('creature_spawn_probability_value').value);
			            if (!isNaN(probability)) components['minecraft:creature_spawn_probability'] = { probability: probability };
			        }
			        if (document.getElementById('enable_humidity').checked) {
			            components['minecraft:humidity'] = { is_humid: document.getElementById('humidity_is_humid').checked };
			        }
			        if (document.getElementById('enable_map_tints').checked) {
			            const mapTints = {};
			            if (document.getElementById('enable_map_tints_foliage').checked) {
			                const foliageColorInput = document.getElementById('map_tints_foliage_color_input');
			                const foliageColor = parseColorInput(foliageColorInput.value);
			                if (foliageColor) {
			                    mapTints.foliage = foliageColor;
			                } else if (foliageColorInput.value.trim() !== '') {
			                    throw new Error("Invalid foliage tint color format. Please use #RRGGBB or rgb(R,G,B).");
			                }
			            }
			            if (document.getElementById('grass_tint_type_noise').checked) {
			                mapTints.grass = { type: "noise" };
			            } else if (document.getElementById('grass_tint_type_custom').checked) {
			                const customTintColorInput = document.getElementById('grass_custom_tint_color_input');
			                const customTintColor = parseColorInput(customTintColorInput.value);
			                if (customTintColor) {
			                    mapTints.grass = { type: "tint", tint: customTintColor };
			                } else {
			                    throw new Error("Invalid grass custom tint color format. Please use #RRGGBB or rgb(R,G,B).");
			                }
			            } else {
			                throw new Error("Grass tint type (Noise or Custom) is required for minecraft:map_tints.");
			            }
			            if (Object.keys(mapTints).length > 0) components['minecraft:map_tints'] = mapTints;
			        }
			        if (document.getElementById('enable_mountain_parameters').checked) {
			            const mountainParams = {};
			            if (document.getElementById('top_slide_enabled').checked) mountainParams.top_slide = { enabled: true };
			            if (document.getElementById('enable_steep_material_adjustment').checked) {
			                const steepMaterial = getBlockSpecifierFromGroup(document.getElementById('steep_material_container'));
			                const steepMaterialAdjustment = {};
			                if (steepMaterial) steepMaterialAdjustment.material = steepMaterial;
			                if (document.getElementById('steep_north_slopes').checked) steepMaterialAdjustment.north_slopes = true;
			                if (document.getElementById('steep_south_slopes').checked) steepMaterialAdjustment.south_slopes = true;
			                if (document.getElementById('steep_east_slopes').checked) steepMaterialAdjustment.east_slopes = true;
			                if (document.getElementById('steep_west_slopes').checked) steepMaterialAdjustment.west_slopes = true;
			                if (Object.keys(steepMaterialAdjustment).length > 0) mountainParams.steep_material_adjustment = steepMaterialAdjustment;
			            }
			            if (Object.keys(mountainParams).length > 0) components['minecraft:mountain_parameters'] = mountainParams;
			        }
			        if (document.getElementById('enable_multinoise_generation_rules').checked) {
			            const multinoise = {};
			            const altitude = parseFloat(document.getElementById('multinoise_target_altitude').value);
			            if (!isNaN(altitude)) multinoise.target_altitude = altitude;
			            const humidity = parseFloat(document.getElementById('multinoise_target_humidity').value);
			            if (!isNaN(humidity)) multinoise.target_humidity = humidity;
			            const temperature = parseFloat(document.getElementById('multinoise_target_temperature').value);
			            if (!isNaN(temperature)) multinoise.target_temperature = temperature;
			            const weirdness = parseFloat(document.getElementById('multinoise_target_weirdness').value);
			            if (!isNaN(weirdness)) multinoise.target_weirdness = weirdness;
			            const weight = parseFloat(document.getElementById('multinoise_weight').value);
			            if (!isNaN(weight)) multinoise.weight = weight;
			            if (Object.keys(multinoise).length > 0) components['minecraft:multinoise_generation_rules'] = multinoise;
			        }
			        if (document.getElementById('enable_overworld_generation_rules').checked) {
			            const overworldGenRules = {};
			            const generateForClimates = [];
			            document.querySelectorAll('#generate_for_climates_container > .dynamic-item').forEach(item => {
			                const category = item.querySelector('select[id$="category"]').value;
			                const weight = parseInt(item.querySelector('input[id$="weight"]').value);
			                if (category && !isNaN(weight)) generateForClimates.push([category, weight]);
			            });
			            if (generateForClimates.length > 0) overworldGenRules.generate_for_climates = generateForClimates;
			            const getTransformationData = (prefix) => {
			                if (document.getElementById(`${prefix}_transform_type_simple`).checked) {
			                    const selected = Array.from(document.getElementById(`${prefix}_transformation_select`).selectedOptions).map(o => o.value);
			                    return selected.length > 0 ? selected : null;
			                }
			                const weighted = [];
			                document.querySelectorAll(`#${prefix}_weighted_biomes_container > .dynamic-item`).forEach(item => {
			                    const name = item.querySelector('select[id$="biome"]').value;
			                    const weight = parseInt(item.querySelector('input[id$="weight"]').value);
			                    if (name && !isNaN(weight)) weighted.push([name, weight]);
			                });
			                return weighted.length > 0 ? weighted : null;
			            };
			            const hills = getTransformationData('hills');
			            if (hills) overworldGenRules.hills_transformation = hills;
			            const mutate = getTransformationData('mutate');
			            if (mutate) overworldGenRules.mutate_transformation = mutate;
			            const river = getTransformationData('river');
			            if (river) overworldGenRules.river_transformation = river;
			            const shore = getTransformationData('shore');
			            if (shore) overworldGenRules.shore_transformation = shore;
			            if (Object.keys(overworldGenRules).length > 0) components['minecraft:overworld_generation_rules'] = overworldGenRules;
			        }
			        if (document.getElementById('enable_overworld_height').checked) {
			            const overworldHeight = {};
			            if (document.getElementById('height_noise_type_radio').checked) {
			                const noiseType = document.getElementById('noise_type_select').value;
			                if (noiseType) overworldHeight.noise_type = noiseType;
			            } else if (document.getElementById('height_noise_params_radio').checked) {
			                const depth = parseFloat(document.getElementById('noise_params_depth').value);
			                const scale = parseFloat(document.getElementById('noise_params_scale').value);
			                if (!isNaN(depth) && !isNaN(scale)) overworldHeight.noise_params = [depth, scale];
			            }
			            if (Object.keys(overworldHeight).length > 0) components['minecraft:overworld_height'] = overworldHeight;
			        }
			        if (document.getElementById('enable_partially_frozen').checked) {
			            components['minecraft:partially_frozen'] = {};
			        }
			        if (document.getElementById('enable_replace_biomes').checked) {
			            const replacements = [];
			            document.querySelectorAll('#replacements_list_container > .dynamic-item').forEach(item => {
			                const dimension = item.querySelector('input[id$="dimension"]').value.trim();
			                const amount = parseFloat(item.querySelector('input[id$="amount"]').value);
			                const scale = parseFloat(item.querySelector('input[id$="noise_freq_scale"]').value);
			                const targets = Array.from(item.querySelector('select[id$="targets_select"]').selectedOptions).map(o => o.value);
			                
			                if (dimension && !isNaN(amount) && !isNaN(scale) && targets.length > 0) {
			                    replacements.push({
			                        dimension: dimension,
			                        amount: amount,
			                        noise_frequency_scale: scale,
			                        targets: targets
			                    });
			                }
			            });
			            
			            if (replacements.length > 0) {
			                components['minecraft:replace_biomes'] = {
			                    replacements: replacements
			                };
			            }
			        }
			        if (document.getElementById('enable_surface_builder').checked) {
			            const builderType = document.getElementById('surface_builder_type_select').value;
			            if (builderType) {
			                const builder = { type: builderType };
			                const getSpec = (name) => {
			                    const container = document.querySelector(`#surface_builder_dynamic_fields .form-group:has(#sb_${name}_name)`);
			                    return container ? getBlockSpecifierFromGroup(container) : null;
			                };
			                const getMultiSpec = (name) => {
			                    const specs = [];
			                    document.querySelectorAll(`#sb_${name}_list_container > .dynamic-item`).forEach(item => {
			                        const spec = getBlockSpecifierFromGroup(item);
			                        if (spec) specs.push(spec);
			                    });
			                    return specs;
			                };
			                switch (builderType) {
			                    case "minecraft:overworld":
			                    case "minecraft:frozen_ocean":
			                    case "minecraft:swamp":
			                        const depth = parseInt(document.getElementById('sb_sea_floor_depth')?.value);
			                        if (!isNaN(depth)) builder.sea_floor_depth = depth;
			                        ['sea_floor_material', 'foundation_material', 'mid_material', 'top_material', 'sea_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        if (builderType === "minecraft:swamp") {
			                            const puddleDepth = parseInt(document.getElementById('sb_max_puddle_depth_below_sea_level')?.value);
			                            if (!isNaN(puddleDepth)) builder.max_puddle_depth_below_sea_level = puddleDepth;
			                        }
			                        break;
			                    case "minecraft:mesa":
			                        const mesaDepth = parseInt(document.getElementById('sb_sea_floor_depth')?.value);
			                        if (!isNaN(mesaDepth)) builder.sea_floor_depth = mesaDepth;
			                        ['sea_floor_material', 'foundation_material', 'mid_material', 'top_material', 'sea_material', 'clay_material', 'hard_clay_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        builder.bryce_pillars = document.getElementById('sb_bryce_pillars')?.checked || false;
			                        builder.has_forest = document.getElementById('sb_has_forest')?.checked || false;
			                        break;
			                    case "minecraft:capped":
			                        const beachSpec = getSpec('beach_material');
			                        if (beachSpec) builder.beach_material = beachSpec;
			                        const ceilingSpecs = getMultiSpec('ceiling_materials');
			                        if (ceilingSpecs.length > 0) builder.ceiling_materials = ceilingSpecs;
			                        const floorSpecs = getMultiSpec('floor_materials');
			                        if (floorSpecs.length > 0) builder.floor_materials = floorSpecs;
			                        ['foundation_material', 'sea_material'].forEach(m => {
			                            const spec = getSpec(m);
			                            if (spec) builder[m] = spec;
			                        });
			                        break;
			                }
			                components['minecraft:surface_builder'] = { builder: builder };
			            }
			        }
			        if (document.getElementById('enable_surface_material_adjustments').checked) {
			            const adjustments = [];
			            document.querySelectorAll('#material_adjustments_container > .dynamic-item').forEach(item => {
			                const uniqueId = item.querySelector('input[id$="noise_min"]').id.replace('noise_min', '');
			                const adjustment = {};
			                const noiseMin = parseFloat(item.querySelector('input[id$="noise_min"]').value);
			                const noiseMax = parseFloat(item.querySelector('input[id$="noise_max"]').value);
			                if (!isNaN(noiseMin) && !isNaN(noiseMax)) adjustment.noise_range = [noiseMin, noiseMax];
			                const heightMin = item.querySelector('input[id$="height_min"]').value.trim();
			                const heightMax = item.querySelector('input[id$="height_max"]').value.trim();
			                if (heightMin && heightMax) adjustment.height_range = [heightMin, heightMax];
			                const scale = parseFloat(item.querySelector('input[id$="noise_freq_scale"]').value);
			                if (!isNaN(scale)) adjustment.noise_frequency_scale = scale;
			                const materials = {};
			                ['top_material', 'foundation_material', 'mid_material', 'sea_floor_material', 'sea_material'].forEach(type => {
			                    const enableToggle = item.querySelector(`#${uniqueId}enable_${type}`);
			                    if (enableToggle && enableToggle.checked) {
			                        const container = item.querySelector(`#${uniqueId}${type}_container`);
			                        const spec = container ? getBlockSpecifierFromGroup(container) : null;
			                        if (spec) materials[type] = spec;
			                    }
			                });
			                if (Object.keys(materials).length > 0) adjustment.materials = materials;
			                if (Object.keys(adjustment).length > 0) adjustments.push(adjustment);
			            });
			            if (adjustments.length > 0) components['minecraft:surface_material_adjustments'] = { adjustments: adjustments };
			        }
			        if (document.getElementById('enable_tags').checked) {
			            const selectedPredefined = Array.from(document.getElementById('biome_tags_select').selectedOptions).map(o => o.value);
			            const allTags = [...new Set([...selectedPredefined, ...customTags])].sort();
			            if (allTags.length > 0) components['minecraft:tags'] = { tags: allTags };
			        }
			        return biomeJson;
			    }
			
			    _initializeForm = function() {
			        setupCollapsibleSections();
			        populateBiomeTags();
			        ['hills_transformation_select', 'mutate_transformation_select', 'river_transformation_select', 'shore_transformation_select'].forEach(populateBiomeSelect);
			        
			        document.querySelectorAll('input[required], select[required], textarea[required]').forEach(el => {
			            if (el.closest('.component-content') || el.closest('.optional-input-content') || el.closest('.dynamic-item')) {
			                 el.dataset.originalRequired = 'true';
			            }
			        });
			
			        createBlockSpecifierInputs(document.getElementById('steep_material_container'), 'steep_material_', null, 'Steep Material (Block Specifier)', false);
			
			        updateColorInputUI(document.getElementById('map_tints_foliage_color_input'), document.getElementById('map_tints_foliage_color_picker'), '#6A7039');
			        document.getElementById('map_tints_foliage_group').style.display = document.getElementById('enable_map_tints_foliage').checked ? 'block' : 'none';
        // ... existing map_tints updateColorInputUI calls ...

        // --- ADDED: Client Biome Color Sync ---
        updateColorInputUI(document.getElementById('sky_color_hex_text'), document.getElementById('sky_color_hex'), '#88AAFF');
        updateColorInputUI(document.getElementById('water_surface_color_text'), document.getElementById('water_surface_color'), '#4455FF');
        updateColorInputUI(document.getElementById('foliage_color_hex_text'), document.getElementById('foliage_color_hex'), '#55AA33');
        updateColorInputUI(document.getElementById('grass_color_hex_text'), document.getElementById('grass_color_hex'), '#77CC44');
        updateColorInputUI(document.getElementById('dry_foliage_hex_text'), document.getElementById('dry_foliage_hex'), '#AAAAAA');
        // ---------------------------------------


			        updateColorInputUI(document.getElementById('grass_custom_tint_color_input'), document.getElementById('grass_custom_tint_color_picker'), '#B6DB61');
			        document.getElementById('grass_custom_tint_group').style.display = document.getElementById('grass_tint_type_custom').checked ? 'block' : 'none';
			        
			        ['hills', 'mutate', 'river', 'shore'].forEach(transformType => {
			            const simpleRadio = document.getElementById(`${transformType}_transform_type_simple`);
			            const weightedRadio = document.getElementById(`${transformType}_transform_type_weighted`);
			            const simpleGroup = document.getElementById(`${transformType}_transformation_simple_group`);
			            const weightedGroup = document.getElementById(`${transformType}_transformation_weighted_group`);
			            const toggleGroups = () => {
			                const isSimple = simpleRadio.checked;
			                simpleGroup.style.display = isSimple ? 'block' : 'none';
			                weightedGroup.style.display = !isSimple ? 'block' : 'none';
			                toggleRequiredFields(simpleGroup, isSimple);
			                toggleRequiredFields(weightedGroup, !isSimple);
			            };
			            simpleRadio.addEventListener('change', toggleGroups);
			            weightedRadio.addEventListener('change', toggleGroups);
			            toggleGroups();
			        });
			
			        document.getElementById('biomeForm').addEventListener('submit', function(event) {
			            event.preventDefault();
			            try {
			                const biomeJson = generateFullBiomeJson();
			                const jsonOutputDiv = document.getElementById('jsonOutput');
			                jsonOutputDiv.textContent = JSON.stringify(biomeJson, null, 2);
			                
			                        // Automatically expand the Server Biome section
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'block';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');
        // --- END ADD ---
			            } catch (error) {
    console.error("JSON Generation Error:", error);
    // --- ADDED ERROR MODAL ---
    showModal({
        title: 'Validation Error', 
        message: error.message || error, 
        onConfirm: ()=>{}
    });
}

			            
			            
			        });
			
			        document.getElementById('copyJsonButton').addEventListener('click', function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            const tempTextArea = document.createElement('textarea');
			            tempTextArea.value = jsonOutput;
			            document.body.appendChild(tempTextArea);
			            tempTextArea.select();
			            try {
			                document.execCommand('copy');
			                showSnackbar('JSON copied to clipboard!');
			            } catch (err) {
			                console.error('Failed to copy JSON: ', err);
			                showModal({title: 'Copy Failed', message: 'Failed to copy JSON. Please copy manually.', onConfirm: ()=>{}});
			            } finally {
			                document.body.removeChild(tempTextArea);
			            }
			        });
			
			        document.getElementById('downloadJsonButton').addEventListener('click', function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            let biomeNameForFile = document.getElementById('identifier').value.trim().split(':').pop() || 'biome';
			            biomeNameForFile = biomeNameForFile.replace(/[^a-z0-9._-]/g, '_').toLowerCase();
			            const filename = `${biomeNameForFile}.biome.json`;
			            const blob = new Blob([jsonOutput], { type: 'application/json' });
			            const url = URL.createObjectURL(blob);
			            const a = document.createElement('a');
			            a.href = url;
			            a.download = filename;
			            document.body.appendChild(a);
			            a.click();
			            document.body.removeChild(a);
			            URL.revokeObjectURL(url);
			        });
			
			        document.getElementById('downloadMcpackButton').addEventListener('click', async function() {
			            const jsonOutput = document.getElementById('jsonOutput').textContent;
			            const identifier = document.getElementById('identifier').value.trim();
			            if (!jsonOutput.trim() || !identifier) {
			                showModal({title: 'Error', message: 'Please generate JSON with a valid identifier first.', onConfirm: ()=>{}});
			                return;
			            }
			            const zip = new JSZip();
			            const packName = `BiBuild Pack-${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;
			            const manifestJson = {
			                "format_version": 2,
			                "header": { "name": packName, "description": "Generated by BiBuild.", "uuid": generateUuidv4(), "version": [1, 0, 0], "min_engine_version": [1, 21, 90] },
			                "modules": [{ "type": "data", "uuid": generateUuidv4(), "version": [1, 0, 0] }]
			            };
			            try {
			                const response = await fetch('icons/icon3.png');
			                if (response.ok) zip.file("pack_icon.png", await response.blob());
			            } catch (e) { console.warn("Could not fetch pack icon.", e); }
			            zip.file("manifest.json", JSON.stringify(manifestJson, null, 2));
			            let biomeFilename = identifier.split(':').pop().replace(/[^a-z0-9._-]/g, '_').toLowerCase() + '.biome.json';
			            zip.file(`biomes/${biomeFilename}`, jsonOutput);
			            try {
			                const content = await zip.generateAsync({ type: "blob" });
			                const a = document.createElement('a');
			                a.href = URL.createObjectURL(content);
			                a.download = `${packName.replace(/ /g, '_').toLowerCase()}.mcpack`;
			                document.body.appendChild(a);
			                a.click();
			                document.body.removeChild(a);
			                URL.revokeObjectURL(a.href);
			                showSnackbar(`Successfully exported "${a.download}"!`);
			            } catch (error) {
			                showModal({title: 'Export Error', message: `Failed to create .mcpack: ${error.message}`, onConfirm: ()=>{}});
			            }
			        });
			
			
			
			        document.getElementById('importJsonButton').addEventListener('click', () => document.getElementById('importJsonFile').click());
    // --- Universal Import Logic ---
    document.getElementById('importJsonFile').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const jsonContent = JSON.parse(e.target.result);
                let loaded = false;

                // 1. Try Loading Server Biome
                if (jsonContent['minecraft:biome']) {
                    _populateFormFromJson(jsonContent);
                    loaded = true;
                }

                // 2. Try Loading Client Biome
                if (jsonContent['minecraft:client_biome']) {
                    // Enable the section first
                    const clientBox = document.getElementById('enable_clientbiomes');
                    clientBox.checked = true;
                    clientBox.dispatchEvent(new Event('change')); // Trigger UI update
                    
                    populateClientForm(jsonContent);
                    loaded = true;
                }

                if (loaded) {
                    showSnackbar('File imported successfully!');
                } else {
                    showModal({title: 'Import Error', message: 'JSON does not appear to be a valid Server or Client biome file.', onConfirm: ()=>{}});
                }

            } catch (error) {
                showModal({title: 'JSON Parse Error', message: `Error parsing file: ${error.message}`, onConfirm: ()=>{}});
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    });

			
			        document.getElementById('refreshButton').addEventListener('click', () => {
			            resetForm();
			            showSnackbar('Form values reset!');
			        });
			
			        document.querySelectorAll('.button').forEach(button => {
			            button.addEventListener('click', function(e) {
			                const ripple = document.createElement('span');
			                ripple.classList.add('ripple');
			                const rect = button.getBoundingClientRect();
			                const size = Math.max(rect.width, rect.height);
			                ripple.style.width = ripple.style.height = `${size}px`;
			                ripple.style.left = `${e.clientX - rect.left - (size / 2)}px`;
			                ripple.style.top = `${e.clientY - rect.top - (size / 2)}px`;
			                this.appendChild(ripple);
			                ripple.addEventListener('animationend', () => ripple.remove());
			            });
			        });
			        
			         document.querySelectorAll('input[name="height_config_type"]').forEach(radio => {
			            radio.addEventListener('change', function() {
			                const noiseTypeGroup = document.getElementById('height_noise_type_group');
			                const noiseParamsGroup = document.getElementById('height_noise_params_group');
			                const isNoiseType = this.value === 'noise_type';
			                noiseTypeGroup.style.display = isNoiseType ? 'block' : 'none';
			                noiseParamsGroup.style.display = !isNoiseType ? 'block' : 'none';
			                toggleRequiredFields(noiseTypeGroup, isNoiseType);
			                toggleRequiredFields(noiseParamsGroup, !isNoiseType);
			            });
			        });
			
			        document.getElementById('surface_builder_type_select').addEventListener('change', function() {
			            renderSurfaceBuilderFields(this.value);
			        });
			
			        document.querySelectorAll('input[name="grass_tint_type"]').forEach(radio => {
			            radio.addEventListener('change', function() {
			                const customTintGroup = document.getElementById('grass_custom_tint_group');
			                const isCustom = this.value === 'tint';
			                customTintGroup.style.display = isCustom ? 'block' : 'none';
			                toggleRequiredFields(customTintGroup, isCustom);
			            });
			        });
			
			        document.getElementById('enable_map_tints_foliage').addEventListener('change', function() {
			            document.getElementById('map_tints_foliage_group').style.display = this.checked ? 'block' : 'none';
			        });
			        
			        document.getElementById('enable_steep_material_adjustment').addEventListener('change', function() {
			             document.getElementById('steep_material_adjustment_group').style.display = this.checked ? 'block' : 'none';
			        });
			
			        document.getElementById('add_climate_category').addEventListener('click', () => addClimateCategoryEntry());
			        document.getElementById('add_material_adjustment').addEventListener('click', () => addMaterialAdjustmentEntry());
			        document.getElementById('add_custom_tag_button').addEventListener('click', () => addCustomTag());
			        document.getElementById('add_hills_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('hills_weighted_biomes_container'));
			        document.getElementById('add_mutate_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('mutate_weighted_biomes_container'));
			        document.getElementById('add_river_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('river_weighted_biomes_container'));
			        document.getElementById('add_shore_weighted_biome').addEventListener('click', () => addWeightedBiomeEntry('shore_weighted_biomes_container'));
			        
			        document.getElementById('add_replacement_button').addEventListener('click', () => addReplacementEntry());
			    };
			})();
		</script>
		<script src="suggestions.js"></script>
		<script>
			/**
			 * Attaches suggestion logic to a single input element.
			 * @param {HTMLInputElement} input The input element to attach the logic to.
			 */
			function attachSuggestionLogic(input) {
			    if (input.dataset.hasSuggestions) {
			        return; // Avoid duplicate setup
			    }
			    input.dataset.hasSuggestions = "true";
			
			    let suggestionBox;
			
			    /**
			     * Creates and initializes the suggestion box element if it doesn't exist.
			     * @returns {HTMLElement} The suggestion box element.
			     */
			    function getOrCreateSuggestionBox() {
			        if (!suggestionBox) {
			            suggestionBox = document.createElement("div");
			            suggestionBox.className = "suggestions";
			            document.body.appendChild(suggestionBox);
			        }
			        return suggestionBox;
			    }
			
			    /**
			     * Positions the suggestion box relative to the input element.
			     * @param {HTMLInputElement} targetInput The input element to position the box against.
			     */
			    function positionSuggestionBox(targetInput) {
			        const rect = targetInput.getBoundingClientRect();
			        suggestionBox.style.left = `${rect.left + window.scrollX}px`;
			        suggestionBox.style.top = `${rect.bottom + window.scrollY + 8}px`; // Add a small margin
			        suggestionBox.style.width = `${rect.width}px`;
			    }
			
			    /**
			     * Hides the suggestion box.
			     */
			    function hideSuggestions() {
			        if (suggestionBox) {
			            suggestionBox.style.display = "none";
			        }
			    }
			
			    // Handle user input
			    input.addEventListener("input", function() {
			        const value = this.value.toLowerCase();
			        // Assuming `window.defaultSuggestions` is a globally available array of strings.
			        const filtered = window.defaultSuggestions.filter(item => item.toLowerCase().includes(value));
			
			        const box = getOrCreateSuggestionBox();
			        positionSuggestionBox(this);
			        box.innerHTML = "";
			
			        if (filtered.length === 0 || !value) {
			            hideSuggestions();
			            return;
			        }
			
			        filtered.forEach(name => {
			            const option = document.createElement("div");
			            option.textContent = name;
			            option.className = "suggestion-item";
			            option.addEventListener("click", () => {
			                input.value = name;
			                hideSuggestions();
			            });
			            box.appendChild(option);
			        });
			
			        box.style.display = "block";
			    });
			
			    // Hide suggestions when the input loses focus, with a slight delay
			    // to allow clicks on the suggestion box itself.
			    input.addEventListener("blur", () => {
			        setTimeout(hideSuggestions, 150);
			    });
			}
			
			/**
			 * Initializes the suggestion system by attaching logic to all existing text inputs
			 * and observing for new inputs added to the DOM.
			 */
			function initSuggestionSystem() {
			    // Attach to all existing text inputs on the page
			    document.querySelectorAll('input[type="text"]').forEach(attachSuggestionLogic);
			
			    // Use a MutationObserver to watch for new text inputs being added dynamically
			    const observer = new MutationObserver(mutations => {
			        for (const mutation of mutations) {
			            mutation.addedNodes.forEach(node => {
			                if (node.tagName === "INPUT" && node.type === "text") {
			                    attachSuggestionLogic(node);
			                } else if (node.querySelectorAll) {
			                    node.querySelectorAll('input[type="text"]').forEach(attachSuggestionLogic);
			                }
			            });
			        }
			    });
			
			    // Start observing the document body for changes
			    observer.observe(document.body, {
			        childList: true,
			        subtree: true
			    });
			}
			
			// Initialize the system once the DOM is fully loaded
			document.addEventListener("DOMContentLoaded", initSuggestionSystem);
			
			// --- You'll need to define `window.defaultSuggestions` somewhere in your project. Example: ---
			// window.defaultSuggestions = ["Material Design", "Expressive", "Components", "Buttons", "Inputs", "Theme"];
		</script>

		<script src="app.js">app.js</script>
		<div class="fab-container">
			<button class="m3-icon-toggle" id="generateBtn">
			<span class="material-symbols-rounded">robot</span>
			</button>
			<button class="m3-icon-toggle" id="manageBtn" data-drawer="manageSheet">
			<span class="material-symbols-rounded">files</span>
			</button>
		</div>
		<div class="bottom-sheet" id="generateSheet">
    <div class="drag-handle-container">
        <div class="drag-handle" data-drawer="generateSheet"></div>
    </div>

    <div class="bottom-sheet-content">
<button type="button" class="generate-code-button button" id="downloadMcaddonButton" style="width: 100%; margin-top: 10px; padding: 26px;">
    <span class="material-symbols-rounded">inventory_2</span>
    Download .mcaddon (BP + RP)
</button>

        <div class="component-section start">
            <h3 class="collapsible-header" data-target="server-biome-content">
                <span class="component-title">Biome (Server)</span>
                <span class="material-symbols-rounded">more</span>
            </h3>
            <div id="server-biome-content" class="component-content">
                <div class="menu-divider"></div>
                <div class="tool-container" style="margin-top: 15px; margin-bottom: 15px;">
                    
                    <div class="tool-management">
                        <!-- ADDED: Server Import Button -->
<input type="file" id="importServerJsonFile" accept=".json" style="display: none;">
<button type="button" id="importServerJsonBtn" class="copy-button" title="Import Server JSON">
    <span class="material-symbols-rounded">file_open</span>
</button>
<!-- END ADDED -->

                        <button type="button" class="copy-button" id="copyJsonButton">
    <span class="material-symbols-rounded">content_copy</span>
</button>
<button type="button" class="download-button" id="downloadJsonButton">
    <span class="material-symbols-rounded">download</span>
</button>
<button type="button" class="download-button" id="downloadMcpackButton">
    <span class="material-symbols-rounded">archive</span>
</button>

                    </div>
                </div>
                <pre id="jsonOutput" class="json-output" style="margin-top: 0;
                height: 250px;
                overflow: auto;"></pre>
            </div>
        </div>

        <div class="component-section end">
            <h3 class="collapsible-header" data-target="client-biome-content">
                <span class="component-title">Client Biome</span>
                <span class="material-symbols-rounded">more</span>
            </h3>
            <div id="client-biome-content" class="component-content">
                <div class="menu-divider"></div>
                
                <div id="validation" class="error" style="color: var(--md-sys-color-error); display:none; margin-top: 10px;"></div>
                <div class="tool-container" style="margin-top: 15px; margin-bottom: 15px;">
                    <div class="tool-management">
                    	<input type="file" id="importClientJsonFile" accept=".json" style="display: none;">
<button type="button" id="importClientJsonBtn" class="copy-button" title="Import Client JSON">
    <span class="material-symbols-rounded">file_open</span>
</button>
                        <button type="button" id="copyBtn" class="copy-button">
                            <span class="material-symbols-rounded">content_copy</span>
                        </button>
                        <button type="button" id="downloadBtn" class="download-button">
                            <span class="material-symbols-rounded">download</span></button>
                        <button type="button" id="downloadClientMcpackButton" class="download-button">
                            <span class="material-symbols-rounded">archive</span>
                        </button>
                        </div>
                </div>
<pre id="outputJson" class="json-output" style="margin-top: 0;
height: 250px; overflow: auto;"></pre>

                


                    </div>
                </div>
            </div>
        </div>

    </div> </div>

		<div class="bottom-sheet" id="manageSheet">
			<div class="drag-handle-container">
				<div class="drag-handle" data-drawer="manageSheet"></div>
			</div>
			<div class="bottom-sheet-content">
				<!-- Preset Management Section -->

				<div class="tool-container" style="padding: 16px; text-align: center;">
    <span class="material-symbols-rounded" 
          style="font-size: 40px; 
                 color: var(--md-sys-color-primary); 
                 font-variation-settings: 'FILL' 1;">
        folder_open
    </span>
</div>
<h2 style="justify-content: center; display: flex;">Manage presets</h2>
				<div class="tool-container">
				    
					<div class="tool-management select">
						
						<label for="presetLoadSelect">Select a preset:</label>
						<select id="presetLoadSelect">
							<option value="">-- No Presets Found --</option>
						</select>
					</div>
				</div>
				<div class="tool-container" >
					<div class="tool-management">
						<button type="button" class="copy-button add-button" id="loadPresetButton">
							<span class="material-symbols-rounded">input</span>
							<div></div>
						</button>
						<button type="button" class="copy-button add-button" id="savePresetButton">
						<span class="material-symbols-rounded">save</span>
						</button>
						<button type="button" class="download-button remove-button" id="deletePresetButton">
						<span class="material-symbols-rounded">delete</span>
						</button>
						<button type="button" class="download-button" id="exportMultipleButton">
						<span class="material-symbols-rounded">collections</span>
						</button>
					</div>
				</div>
			</div>
		</div>
		<script>
			const allSheets = [document.getElementById("generateSheet"), document.getElementById("manageSheet")];
			const allButtons = [document.getElementById("generateBtn"), document.getElementById("manageBtn")];
			const dragHandles = document.querySelectorAll('.drag-handle');
			
			let startY = 0;
			let currentSheet = null;
			let currentHandle = null; 
			const TRANSITION_STYLE = 'transform 0.4s cubic-bezier(0.25, 0.1, 0.25, 1.0)';
			
			// --- Core Drawer/Button Toggle Logic ---
			
			function closeAllSheets() {
			  allSheets.forEach(sheet => {
			    // Check if sheet exists before trying to access properties
			    if (sheet) {
			      sheet.classList.remove("active");
			      sheet.style.transform = 'translateY(100%)'; 
			    }
			  });
			  // FIX: Explicitly remove active state from all buttons to prevent 'stuck' state
			  allButtons.forEach(btn => btn.classList.remove("active"));
			}
			
			function handleToggle(clickedButton, associatedSheet) {
			    const isActive = clickedButton.classList.contains("active");
			    closeAllSheets(); 
			
			    if (!isActive) {
			        associatedSheet.style.transform = 'translateY(0)'; 
			        clickedButton.classList.add("active");
			        associatedSheet.classList.add("active");
			    }
			}
			
			// --- Event Listeners for Buttons and Scrim Click (Unchanged) ---
			
			allButtons.forEach(button => {
			    button.addEventListener("click", (e) => {
			        e.preventDefault();
			        const sheetId = button.getAttribute('data-drawer');
			        const sheet = document.getElementById(sheetId);
			        handleToggle(button, sheet);
			    });
			});
			
			document.addEventListener("click", (e) => {
			  if (!e.target.closest(".bottom-sheet") && 
			      !e.target.closest(".fab-container")) {
			    closeAllSheets();
			  }
			});
			
			// --- DRAG HANDLE FUNCTIONALITY (FIXED & CLEANED) ---
			
			function preventDefaultTouch(e) {
			    e.preventDefault();
			}
			
			function cleanupListeners() {
			    document.removeEventListener('mousemove', dragMove);
			    document.removeEventListener('touchmove', dragMove);
			    document.removeEventListener('mouseup', dragEnd);
			    document.removeEventListener('touchend', dragEnd);
			    
			    if (currentHandle) {
			        currentHandle.removeEventListener('touchmove', preventDefaultTouch);
			    }
			    
			    currentSheet = null; 
			    currentHandle = null;
			}
			
			
			function dragStart(e) {
			    currentHandle = e.currentTarget; 
			    const sheetId = currentHandle.dataset.drawer;
			    currentSheet = document.getElementById(sheetId);
			    if (!currentSheet || !currentSheet.classList.contains('active')) return;
			    
			    startY = e.touches ? e.touches[0].clientY : e.clientY;
			    currentSheet.style.transition = 'none';
			    
			    document.addEventListener('mousemove', dragMove);
			    document.addEventListener('touchmove', dragMove);
			    document.addEventListener('mouseup', dragEnd);
			    document.addEventListener('touchend', dragEnd);
			    
			    if (e.type === 'touchstart') {
			        currentHandle.addEventListener('touchmove', preventDefaultTouch, { passive: false });
			    }
			}
			
			function dragMove(e) {
			    if (!currentSheet) return;
			
			    const currentY = e.touches ? e.touches[0].clientY : e.clientY;
			    let deltaY = currentY - startY;
			    
			    if (deltaY < 0) {
			        deltaY = 0;
			    }
			
			    currentSheet.style.transform = `translateY(${deltaY}px)`;
			}
			
			function dragEnd(e) {
			    // 1. Initial Check: Exit immediately if currentSheet is null
			    if (!currentSheet) {
			        cleanupListeners(); // Ensure listeners are removed if somehow called without a sheet
			        return;
			    }
			    
			    // Use a local reference to the sheet before cleanup, if needed later
			    const sheetToClose = currentSheet; 
			
			    // 2. Re-enable transition
			    sheetToClose.style.transition = TRANSITION_STYLE;
			
			    // 3. Calculate drag distance
			    const finalY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
			    const deltaY = finalY - startY;
			    
			    const closeThreshold = sheetToClose.offsetHeight * 0.25;
			
			    if (deltaY > closeThreshold) {
			        // Dragged far enough: Trigger smooth close
			        sheetToClose.style.transform = 'translateY(100%)'; 
			        
			        // 4. Cleanup after transition (400ms)
			        setTimeout(() => {
			            // FIX: Use the shared closeAllSheets function which handles the classList removal safely
			            closeAllSheets(); 
			        }, 400); 
			        
			    } else {
			        // Snap back to open position
			        sheetToClose.style.transform = 'translateY(0)';
			    }
			
			    // 5. Cleanup Listeners and reset references IMMEDIATELY after deciding snap/close
			    cleanupListeners();
			}
			
			// Attach listeners
			dragHandles.forEach(handle => {
			    handle.addEventListener('mousedown', dragStart);
			    handle.addEventListener('touchstart', dragStart, { passive: false }); 
			});
		</script>
		<script>
			const biomeForm = document.getElementById('biomeForm');
			const generateBtn = document.getElementById('generateBtn');
			const formSubmitBtn = document.getElementById('formSubmitBtn');
			
			let triggeredBy = null; // prevent recursion
			
			// shared logic for generation
			function handleBiomeGeneration() {
			  // _generateJson();  // your real generation logic
			}
			
			// when the form submits
			biomeForm.addEventListener('submit', (e) => {
			  e.preventDefault();
			  
			  if (!biomeForm.checkValidity()) {
			    biomeForm.reportValidity(); // show validation UI if invalid
			    return;
			  }
			  
			  if (triggeredBy === 'generateBtn') {
			    triggeredBy = null;
			    handleBiomeGeneration(); // run generation logic only once
			    return;
			  }
			  
			  // if submit button triggered the submit
			  triggeredBy = 'formSubmit';
			  generateBtn.click(); // simulate pressing Generate
			  triggeredBy = null;
			});
			
			// when clicking the Generate button
			generateBtn.addEventListener('click', () => {
			  if (triggeredBy === 'formSubmit') return; // avoid recursion
			  
			  // check required fields before submit
			  if (!biomeForm.checkValidity()) {
			    biomeForm.reportValidity(); // show built-in popup
			    return; // don't submit or trigger anything
			  }
			  
			  triggeredBy = 'generateBtn';
			  biomeForm.requestSubmit(); // valid → trigger form submit event
			  triggeredBy = null;
			});
		</script>
		<script>
			const moreButton = document.getElementById('more-button');
			const dropdownMenu = document.getElementById('dropdown-menu');
			const themeToggleLink = document.getElementById('theme-toggle');
			const themeToggleButton = themeToggleLink.querySelector('.trailing-icon-button');
			const aboutButton = document.getElementById('about-button');
			const aboutDialogBackdrop = document.getElementById('about-dialog-backdrop');
			const closeAboutButton = document.getElementById('close-about-button');
			
			
			// --- THEME LOGIC ---
			
			function updateThemeIcon(isDark) {
			    const icon = themeToggleButton.querySelector('.material-symbols-rounded');
			    icon.textContent = isDark ? 'toggle_on' : 'toggle_off';
			    icon.style.color = isDark ? 'var(--md-sys-color-primary)' : 'var(--md-sys-color-on-surface-variant)';
			    themeToggleButton.setAttribute('data-toggled', isDark ? 'on' : 'off');
			}
			
			function toggleDarkTheme(forceDark = null) {
			    const isDark = forceDark !== null ? forceDark : !document.documentElement.classList.contains('dark-theme');
			    document.documentElement.classList.toggle('dark-theme', isDark);
			    updateThemeIcon(isDark);
			    
			    // Persist the user's choice (optional, but good practice)
			    localStorage.setItem('theme', isDark ? 'dark' : 'light');
			}
			
			// Initialize theme based on system preference or saved choice
			function initializeTheme() {
			    const savedTheme = localStorage.getItem('theme');
			    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
			    
			    if (savedTheme === 'dark' || (savedTheme === null && systemPrefersDark)) {
			        toggleDarkTheme(true);
			    } else {
			        toggleDarkTheme(false);
			    }
			}
			
			// Run theme initialization
			initializeTheme();
			
			// --- EVENT LISTENERS ---
			
			// Dropdown toggle
			moreButton.addEventListener('click', (e) => {
			    e.stopPropagation();
			    dropdownMenu.classList.toggle('visible');
			});
			
			// Close dropdown when clicking outside
			document.addEventListener('click', (event) => {
			    if (!moreButton.contains(event.target) && !dropdownMenu.contains(event.target) && !aboutDialogBackdrop.contains(event.target)) {
			        dropdownMenu.classList.remove('visible');
			    }
			});
			
			// Theme Toggle Click Handler
			themeToggleLink.addEventListener('click', (e) => {
			    e.preventDefault();
			    e.stopPropagation(); 
			    toggleDarkTheme();
			});
			
			// About Dialog Handlers
			aboutButton.addEventListener('click', (e) => {
			    e.preventDefault();
			    dropdownMenu.classList.remove('visible');
			    aboutDialogBackdrop.classList.add('visible');
			});
			
			closeAboutButton.addEventListener('click', () => {
			    aboutDialogBackdrop.classList.remove('visible');
			});
			
			aboutDialogBackdrop.addEventListener('click', (e) => {
			    if (e.target === aboutDialogBackdrop) {
			        aboutDialogBackdrop.classList.remove('visible');
			    }
			});
			
			
    // --- Server Sheet Import Listeners ---
    const importServerBtn = document.getElementById('importServerJsonBtn');
    const importServerFile = document.getElementById('importServerJsonFile');

    if(importServerBtn && importServerFile) {
        importServerBtn.addEventListener('click', () => {
            importServerFile.click();
        });

        importServerFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    if (json['minecraft:biome']) {
                        _populateFormFromJson(json);
                        // Also update the preview since we are in the sheet
                        document.getElementById('jsonOutput').textContent = JSON.stringify(json, null, 2);
                        showSnackbar("Server Biome Imported!");
                    } else {
                        alert("This file does not contain a 'minecraft:biome' definition.");
                    }
                } catch (err) {
                    alert("Invalid JSON file.");
                }
            };
            reader.readAsText(file);
            e.target.value = ''; 
        });
    }

		</script>
		<script>
			const fabContainer = document.querySelector('.fab-container');
			let lastScrollY = window.scrollY;
			let isHidden = false;
			let scrollTimeout;
			
			window.addEventListener('scroll', () => {
			  clearTimeout(scrollTimeout);
			
			  // hide when scrolling down
			  if (window.scrollY > lastScrollY && !isHidden) {
			    fabContainer.classList.add('hide');
			    isHidden = true;
			  }
			  // show when scrolling up
			  else if (window.scrollY < lastScrollY && isHidden) {
			    fabContainer.classList.remove('hide');
			    isHidden = false;
			  }
			
			  lastScrollY = window.scrollY;
			
			  // if scroll stops, show again after short delay
			  
			});
		</script>
		<script>
			const box = document.getElementById('enable_clientbiomes');
			// --- Function to read query parameter ---
			function getQueryParam(name) {
			  const params = new URLSearchParams(window.location.search);
			  return params.get(name);
			}
			// --- Initialize checkbox based on query ---
			function initCheckbox() {
			  const state = getQueryParam('clientbiomes');
			  if (state === 'on') box.checked = true;
			  else if (state === 'off') box.checked = false;
			}
			// --- Update query parameter when checkbox changes ---
			function updateQuery() {
			  const params = new URLSearchParams(window.location.search);
			  params.set('clientbiomes', box.checked ? 'on' : 'off');
			  const newUrl = `${window.location.pathname}?${params.toString()}`;
			  history.replaceState({}, '', newUrl);
			}
			box.addEventListener('change', updateQuery);
			// --- Run once on page load ---
			initCheckbox();
		</script>
		<script>
			const btn = document.getElementById('fullscreenBtn');
			
			btn.addEventListener('click', async () => {
			  if (!document.fullscreenElement) {
			    await document.documentElement.requestFullscreen();
			  } else {
			    await document.exitFullscreen();
			  }
			});
			
			
		</script>
		<script>
			/* Utilities */
			const $ = id => document.getElementById(id);
			const show = (el) => el.style.display = '';
			const hide = (el) => el.style.display = 'none';
			
			/* Toggle controls */
			[
			  ['comp_sky_color','sky_controls'],
			  ['comp_water_appearance','water_controls'],
			  ['comp_fog','fog_controls'],
			  ['comp_foliage','foliage_controls'],
			  ['comp_grass','grass_controls'],
			  ['comp_atmosphere','atmosphere_controls'],
			  ['comp_color_grading','color_grading_controls'],
			  ['comp_cubemap','cubemap_controls'],
			  ['comp_lighting','lighting_controls'],
			  ['comp_precip','precip_controls'],
			  ['comp_ambient','ambient_controls'],
			  ['comp_underwater_ambient','underwater_ambient_block'],
			  ['comp_music','music_controls'],
			  ['comp_dry_foliage','dry_foliage_controls'],
			].forEach(pair=>{
			  const cb = $(pair[0]); const body = $(pair[1]);
			  if(!cb || !body) return;
			  cb.addEventListener('change', ()=> {
			    if(cb.checked) show(body); else hide(body);
			  });
			});
			
			/* precipitation mode */
			$('precip_mode').addEventListener('change', (e)=>{
			  const mode = e.target.value;
			  if(mode === 'single'){ show($('precip_single')); hide($('precip_advanced')); }
			  else { hide($('precip_single')); show($('precip_advanced')); }
			});
			
			/* ambient underwater toggle (checkbox inside ambient section) */
			$('comp_underwater_ambient').addEventListener('change', (e)=>{
			  const el = $('underwater_ambient_block');
			  if(e.target.checked) show(el); else hide(el);
			});
			
			
			/* validation helper for identifier */
			function validateIdentifier(id){
			  // pattern from docs: ^[a-z0-9.%+\-]+:[a-z0-9.%+\-]+$
			  const re = /^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/;
			  return re.test(id);
			}
			
			/* Build the components object following docs */
			function buildComponents(){
			  const comps = {};
			
			  /* sky_color */
			  if($('comp_sky_color').checked){
			    const arrText = $('sky_color_arr').value.trim();
			    if(arrText){
			      try{ const arr = JSON.parse(arrText); if(Array.isArray(arr)) comps["minecraft:sky_color"] = { "sky_color": arr }; else throw 'not array'; }
			      catch(e){ throw "sky_color array must be valid JSON array e.g. [136,170,255]"; }
			    } else {
			      comps["minecraft:sky_color"] = { "sky_color": $('sky_color_hex').value };
			    }
			  }
			
			  /* water_appearance and water_identifier */
			  if($('comp_water_appearance').checked){
			    const obj = {};
			    const hex = $('water_surface_color').value;
			    if(hex) obj["surface_color"] = hex;
			    const opa = parseFloat($('water_surface_opacity').value);
			    if(!isNaN(opa)) obj["surface_opacity"] = opa;
			    if(Object.keys(obj).length) comps["minecraft:water_appearance"] = obj;
			  }
			  if($('comp_water_appearance').checked && $('water_identifier').value.trim()){
			    // docs separate water_identifier component
			    comps["minecraft:water_identifier"] = { "water_identifier": $('water_identifier').value.trim() };
			  } else if($('comp_water_appearance').checked && $('water_identifier').value.trim()===""){
			    // nothing
			  }
			
			  /* fog_appearance */
			  if($('comp_fog').checked){
			    const fid = $('fog_identifier').value.trim();
			    if(!fid) throw "fog_appearance: fog_identifier must be provided when enabled.";
			    comps["minecraft:fog_appearance"] = { "fog_identifier": fid };
			  }
			
			  /* foliage_appearance */
			  if($('comp_foliage').checked){
			    const map = $('foliage_color_map').value;
			    if(map){
			      comps["minecraft:foliage_appearance"] = { "color_map": map };
			    } else {
			      comps["minecraft:foliage_appearance"] = { "color": $('foliage_color_hex').value };
			    }
			  }
			
			  /* grass_appearance */
			  if($('comp_grass').checked){
			    const map = $('grass_color_map').value;
			    const obj = {};
			    if(map) obj["color_map"] = map;
			    else obj["color"] = $('grass_color_hex').value;
			    if($('grass_is_shaded').checked) obj["grass_is_shaded"] = true;
			    comps["minecraft:grass_appearance"] = obj;
			  }
			
			  /* dry_foliage_color */
			  if($('comp_dry_foliage').checked){
			    const arr = $('dry_foliage_array').value.trim();
			    if(arr){
			      try{ const parsed = JSON.parse(arr); if(Array.isArray(parsed)) comps["minecraft:dry_foliage_color"] = { "color": parsed }; else throw 'not array'; }
			      catch(e){ throw "dry_foliage_color: RGB array must be valid JSON array e.g. [170,170,170]"; }
			    } else {
			      comps["minecraft:dry_foliage_color"] = { "color": $('dry_foliage_hex').value };
			    }
			  }
			
			  /* vibrant visuals identifiers */
			  if($('comp_atmosphere').checked){
			    const a = $('atmosphere_identifier').value.trim();
			    if(!a) throw "atmosphere_identifier enabled but empty.";
			    comps["minecraft:atmosphere_identifier"] = { "atmosphere_identifier": a };
			  }
			  if($('comp_color_grading').checked){
			    const c = $('color_grading_identifier').value.trim();
			    if(!c) throw "color_grading_identifier enabled but empty.";
			    comps["minecraft:color_grading_identifier"] = { "color_grading_identifier": c };
			  }
			  if($('comp_cubemap').checked){
			    const c = $('cubemap_identifier').value.trim();
			    if(!c) throw "cubemap_identifier enabled but empty.";
			    comps["minecraft:cubemap_identifier"] = { "cubemap_identifier": c };
			  }
			  if($('comp_lighting').checked){
			    const c = $('lighting_identifier').value.trim();
			    if(!c) throw "lighting_identifier enabled but empty.";
			    comps["minecraft:lighting_identifier"] = { "lighting_identifier": c };
			  }
			
			  /* precipitation */
			  if($('comp_precip').checked){
			    const mode = $('precip_mode').value;
			    if(mode === 'single'){
			      const type = $('precip_type').value;
			      const dens = $('precip_density').value.trim();
			      if(!type) throw "Precipitation: choose type (or disable precipitation).";
			      const d = dens === "" ? 0 : parseFloat(dens);
			      if(isNaN(d)) throw "Precipitation density must be a number.";
			      const obj = {}; obj[type] = d;
			      comps["minecraft:precipitation"] = obj;
			    } else {
			      // advanced multiple allowed
			      const obj = {};
			      const ash = parseFloat($('precip_ash').value) || 0;
			      const blue = parseFloat($('precip_blue_spores').value) || 0;
			      const red = parseFloat($('precip_red_spores').value) || 0;
			      const white = parseFloat($('precip_white_ash').value) || 0;
			      if(ash>0) obj["ash"]=ash;
			      if(blue>0) obj["blue_spores"]=blue;
			      if(red>0) obj["red_spores"]=red;
			      if(white>0) obj["white_ash"]=white;
			      if(Object.keys(obj).length === 0) throw "Precipitation (advanced): no densities set.";
			      comps["minecraft:precipitation"] = obj;
			    }
			  }
			
			  /* ambient sounds */
			// Replace your existing ambient-sounds block with this code
			if ($('comp_ambient').checked) {
			  const ambient = {};
			
			  // loop -> should be a string (identifier)
			  const loop = $('ambient_loop').value.trim();
			  if (loop) ambient["loop"] = loop;
			
			  // addition -> object { asset, chance }
			  const add_asset = $('ambient_add_asset').value.trim();
			  const add_chance = $('ambient_add_chance').value.trim();
			  if (add_asset) {
			    const chanceNum = add_chance === "" ? 1.0 : parseFloat(add_chance);
			    if (isNaN(chanceNum) || chanceNum < 0 || chanceNum > 1) throw "Ambient addition chance must be 0.0–1.0";
			    ambient["addition"] = { "asset": add_asset, "chance": chanceNum };
			  }
			
			  // mood -> should be a string (identifier)
			  const mood = $('ambient_mood').value.trim();
			  if (mood) ambient["mood"] = mood;
			
			  // Underwater variants
			  if ($('comp_underwater_ambient').checked) {
			    const ua = $('underwater_add_asset').value.trim();
			    const uc = $('underwater_add_chance').value.trim();
			    if (ua) {
			      const chanceNum = uc === "" ? 1.0 : parseFloat(uc);
			      if (isNaN(chanceNum) || chanceNum < 0 || chanceNum > 1) throw "Underwater addition chance must be 0.0–1.0";
			      ambient["underwater_addition"] = { "asset": ua, "chance": chanceNum };
			    }
			
			    // underwater_loop -> string
			    const ul = $('underwater_loop').value.trim();
			    if (ul) ambient["underwater_loop"] = ul;
			
			    // underwater_mood -> string
			    const um = $('underwater_mood').value.trim();
			    if (um) ambient["underwater_mood"] = um;
			  }
			
			  if (Object.keys(ambient).length) {
			    comps["minecraft:ambient_sounds"] = ambient;
			  }
			}
			
			  /* biome music */
			  if($('comp_music').checked){
			    const md = $('music_definition').value.trim();
			    const vm = parseFloat($('music_volume').value);
			    const um = $('music_underwater').value;
			    const obj = {};
			    if(md !== "") obj["music_definition"] = md;
			    if(!isNaN(vm)) obj["volume_multiplier"] = vm;
			    if(um === "true") obj["underwater_music"] = true;
			    else if(um === "false") obj["underwater_music"] = false;
			    comps["minecraft:biome_music"] = obj;
			  }
			
			  return comps;
			}
			
			/* generate button */
			$('generateBtn').addEventListener('click', () => {
    $('validation').style.display = 'none';
    $('validation').innerText = '';

    // --- REQUEST 2: Check Validity First ---
    const form = document.getElementById('biomeForm');
    if (!form.checkValidity()) {
        form.reportValidity(); // Shows browser native validation bubbles
        return; // STOP here. Do not open sheet.
    }
    // ---------------------------------------

    try {
        // 1. Generate Server Biome (Always happens)
        const identifier = $('identifier').value.trim().toLowerCase();
        const fv = $('format_version').value.trim();
        if (!validateIdentifier(identifier)) {
            throw "Identifier invalid. Use namespace:biome_name pattern (lowercase).";
        }
        
        // Use original value setter (no lowercase force) to keep user input style if desired, 
        // but validation forces format anyway.
        const components = buildComponents();
        const output = {
            "format_version": fv,
            "minecraft:client_biome": {
                "description": {
                    "identifier": identifier
                },
                "components": components
            }
        };

        const serverJson = generateFullBiomeJson(); // Generate server JSON
        $('jsonOutput').textContent = JSON.stringify(serverJson, null, 2);
        
        // Expand Server Section
        const serverContent = document.getElementById('server-biome-content');
        serverContent.style.display = 'block';
        serverContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');

        // --- REQUEST 3: Handle Client Biome Toggle ---
        const clientEnabled = document.getElementById('enable_clientbiomes').checked;
        const clientContent = document.getElementById('client-biome-content');
        
        if (clientEnabled) {
            // Generate Client JSON only if enabled
            $('outputJson').textContent = JSON.stringify(output, null, 2);
            
            // Show Client Section
            clientContent.style.display = 'block';
            clientContent.closest('.component-section').querySelector('.collapsible-header').classList.remove('collapsed');
        } else {
            // Clear Client JSON
            $('outputJson').textContent = "";
            
            // Hide/Collapse Client Section
            clientContent.style.display = 'none';
            clientContent.closest('.component-section').querySelector('.collapsible-header').classList.add('collapsed');
        }
        // ---------------------------------------------

        // --- REQUEST 2: Open Sheet Manually on Success ---
        const sheet = document.getElementById('generateSheet');
        const btn = document.getElementById('generateBtn');
        // Use existing handleToggle logic from your app.js logic
        if (!sheet.classList.contains('active')) {
             handleToggle(btn, sheet);
        }
        // -------------------------------------------------

    } catch (err) {
        $('validation').style.display = 'block';
        $('validation').innerText = err.toString();
        // Scroll to validation error if needed, do not open sheet
    }
});

			
			/* download & copy handling */
			$('downloadBtn').addEventListener('click', ()=>{
			  const text = $('outputJson').textContent;
			  if(!text){ alert("Generate JSON first."); return; }
			  const blob = new Blob([text], {type:'application/json'});
			  const url = URL.createObjectURL(blob);
			  const a = document.createElement('a');
			  const fname = $('identifier').value.trim().replace(/[:]/g,'_') + "_client_biome.json";
			  a.href = url; a.download = fname; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
			});
			$('copyBtn').addEventListener('click', ()=>{
			  const text = $('outputJson').textContent;
			  if(!text){ alert("Generate JSON first."); return; }
			  navigator.clipboard.writeText(text).then(()=>{ alert("Copied JSON to clipboard"); }, ()=>{ alert("Copy failed"); });
			});
			// --- Client Import Event Listeners ---
$('importClientJsonBtn').addEventListener('click', () => {
    $('importClientJsonFile').click();
});

$('importClientJsonFile').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const json = JSON.parse(event.target.result);
            populateClientForm(json);
        } catch (err) {
            alert("Invalid JSON file.");
        }
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset so same file can be selected again
});

			
$('downloadClientMcpackButton').addEventListener('click', async () => {
    const jsonOutput = $('outputJson').textContent;
    const identifier = $('identifier').value.trim();

    if (!jsonOutput.trim() || !identifier) {
        alert('Please generate the client biome JSON first and ensure an identifier is set.');
        return;
    }

    if (!validateIdentifier(identifier)) {
        alert("Identifier invalid. Use namespace:biome_name pattern (lowercase).");
        return;
    }

    let clientBiomeData;
    try {
        clientBiomeData = JSON.parse(jsonOutput);
    } catch (e) {
        alert("Generated JSON is invalid. Please try generating again.");
        return;
    }

    // --- CHANGED LOGIC STARTS HERE ---

    // 1. Extract the name part from "namespace:name"
    const namePart = identifier.split(':')[1] || identifier; 
    // 2. Sanitize to ensure valid filename (replace special chars with underscore)
    const cleanName = namePart.replace(/[^a-z0-9._-]/g, '_').toLowerCase();
    // 3. Construct filename
    const fileName = `${cleanName}.client_biome.json`;

    const zip = new JSZip();
    const packName = `BiBuild Client Pack-${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`;

    // Create a RESOURCE PACK manifest
    const manifestJson = {
        "format_version": 2,
        "header": {
            "name": packName,
            "description": "Client biome resource pack generated by BiBuild.",
            "uuid": generateUuidv4(),
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 90]
        },
        "modules": [
            {
                "type": "resources",
                "uuid": generateUuidv4(),
                "version": [1, 0, 0]
            }
        ]
    };

    // Add pack icon
    try {
        const response = await fetch('icons/icon3.png');
        if (response.ok) zip.file("pack_icon.png", await response.blob());
    } catch (e) {
        console.warn("Could not fetch pack icon.", e);
    }

    // Add manifest to root
    zip.file("manifest.json", JSON.stringify(manifestJson, null, 2));

    // 4. Create 'biomes' folder and add the file inside it
    const biomesFolder = zip.folder("biomes");
    biomesFolder.file(fileName, JSON.stringify(clientBiomeData, null, 2));

    // --- CHANGED LOGIC ENDS HERE ---

    // Generate and download the .mcpack
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName.replace(/ /g, '_').toLowerCase()}.mcpack`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        alert(`Successfully exported "${a.download}"!`);
    } catch (error) {
        alert(`Failed to create .mcpack: ${error.message}`);
    }
});


			
			/* basic keyboard shortcut: Ctrl+G to generate */
			document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='g'){ e.preventDefault(); $('generateBtn').click(); } });
			
			/* small UX: when user changes color, show swatches already done above */
			/* done earlier */
			
		</script>
		<script>
			document.addEventListener('DOMContentLoaded', () => {
			  const checkbox = document.getElementById('enable_clientbiomes');
			  const hiddenContainer = document.getElementById('hidden-container');
			
			  checkbox.addEventListener('change', () => {
			    hiddenContainer.style.display = checkbox.checked ? 'block' : 'none';
			  });
			});
		</script>
		<script>
document.addEventListener('DOMContentLoaded', () => {
    // This function makes the new "Biome (Server)" and "Client Biome" headers clickable
    function setupSheetCollapsibles() {
        const sheet = document.getElementById('generateSheet');
        if (!sheet) return;

        // Find the specific headers inside the generateSheet
        sheet.querySelectorAll('.collapsible-header[data-target="server-biome-content"], .collapsible-header[data-target="client-biome-content"]')
            .forEach(header => {
                const contentId = header.dataset.target;
                const content = document.getElementById(contentId);

                if (content) {
                    // Start them as collapsed
                    content.style.display = 'none';
                    header.classList.add('collapsed');

                    // Add click event listener to the header itself
                    header.addEventListener('click', (event) => {
                        // Prevent clicks on any inner buttons from triggering collapse
                        if (event.target.closest('button, .switch, a')) {
                            return;
                        }
                        
                        const isCollapsed = content.style.display === 'none';
                        
                        content.style.display = isCollapsed ? 'block' : 'none';
                        header.classList.toggle('collapsed', !isCollapsed);
                    });
                }
            });
    }

    // Run this new setup function
    setupSheetCollapsibles();
});

// --- Client Biome Import Logic ---

function populateClientForm(data) {
    try {
        const root = data['minecraft:client_biome'];
        if (!root) throw new Error("Invalid Client Biome JSON: Missing 'minecraft:client_biome'");
        
        const desc = root.description;
        const comps = root.components;

        // 1. Set Identifier
        if (desc && desc.identifier) {
            $('identifier').value = desc.identifier;
        }

        // Helper to toggle switch and trigger change event (to show/hide sub-menus)
        const toggleComp = (id, state) => {
            const el = $(id);
            if (el) {
                el.checked = state;
                el.dispatchEvent(new Event('change'));
            }
        };

        // Helper to set value if exists
        const setVal = (id, val) => { if ($(id) && val !== undefined) $(id).value = val; };
        
        // Helper to set color (updates both picker and text)
        const setColor = (textId, pickerId, val) => {
            if (!val) return;
            if (typeof val === 'string') {
                setVal(textId, val);
                setVal(pickerId, val);
            } else if (Array.isArray(val)) {
                // If it's an RGB array, put it in the array input (if specific field exists) or text
                 // This depends on specific field logic, usually we just fill the array input
            }
        };

        if (!comps) return;

        // --- Sky Color ---
        if (comps['minecraft:sky_color']) {
            toggleComp('comp_sky_color', true);
            const sc = comps['minecraft:sky_color'].sky_color;
            if (Array.isArray(sc)) {
                setVal('sky_color_arr', JSON.stringify(sc));
            } else {
                setColor('sky_color_hex_text', 'sky_color_hex', sc);
            }
        } else toggleComp('comp_sky_color', false);

        // --- Water Appearance ---
        if (comps['minecraft:water_appearance']) {
            toggleComp('comp_water_appearance', true);
            const wa = comps['minecraft:water_appearance'];
            setColor('water_surface_color_text', 'water_surface_color', wa.surface_color);
            setVal('water_surface_opacity', wa.surface_opacity);
        } else toggleComp('comp_water_appearance', false);
        
        // Water Identifier (often separate in JSON)
        if (comps['minecraft:water_identifier']) {
             // Ensure the section is open if only identifier exists
             toggleComp('comp_water_appearance', true); 
             setVal('water_identifier', comps['minecraft:water_identifier'].water_identifier);
        }

        // --- Fog ---
        if (comps['minecraft:fog_appearance']) {
            toggleComp('comp_fog', true);
            setVal('fog_identifier', comps['minecraft:fog_appearance'].fog_identifier);
        } else toggleComp('comp_fog', false);

        // --- Foliage ---
        if (comps['minecraft:foliage_appearance']) {
            toggleComp('comp_foliage', true);
            const fa = comps['minecraft:foliage_appearance'];
            if (fa.color_map) setVal('foliage_color_map', fa.color_map);
            else setColor('foliage_color_hex_text', 'foliage_color_hex', fa.color);
        } else toggleComp('comp_foliage', false);

        // --- Grass ---
        if (comps['minecraft:grass_appearance']) {
            toggleComp('comp_grass', true);
            const ga = comps['minecraft:grass_appearance'];
            if (ga.color_map) setVal('grass_color_map', ga.color_map);
            else setColor('grass_color_hex_text', 'grass_color_hex', ga.color);
            $('grass_is_shaded').checked = !!ga.grass_is_shaded;
        } else toggleComp('comp_grass', false);

        // --- Identifiers ---
        const idMap = [
            ['minecraft:atmosphere_identifier', 'comp_atmosphere', 'atmosphere_identifier'],
            ['minecraft:color_grading_identifier', 'comp_color_grading', 'color_grading_identifier'],
            ['minecraft:cubemap_identifier', 'comp_cubemap', 'cubemap_identifier'],
            ['minecraft:lighting_identifier', 'comp_lighting', 'lighting_identifier']
        ];
        idMap.forEach(item => {
            if (comps[item[0]]) {
                toggleComp(item[1], true);
                setVal(item[2], comps[item[0]][item[2]]); // Key matches ID
            } else toggleComp(item[1], false);
        });

        // --- Dry Foliage ---
        if (comps['minecraft:dry_foliage_color']) {
            toggleComp('comp_dry_foliage', true);
            const df = comps['minecraft:dry_foliage_color'].color;
            if (Array.isArray(df)) setVal('dry_foliage_array', JSON.stringify(df));
            else setColor('dry_foliage_hex_text', 'dry_foliage_hex', df);
        } else toggleComp('comp_dry_foliage', false);

        // --- Precipitation ---
        if (comps['minecraft:precipitation']) {
            toggleComp('comp_precip', true);
            const p = comps['minecraft:precipitation'];
            // Check if it is advanced (multiple keys) or single
            const keys = Object.keys(p);
            const complexKeys = ['ash', 'blue_spores', 'red_spores', 'white_ash'];
            const isAdvanced = keys.some(k => complexKeys.includes(k));

            if (isAdvanced) {
                setVal('precip_mode', 'advanced');
                $('precip_mode').dispatchEvent(new Event('change'));
                complexKeys.forEach(k => setVal(`precip_${k}`, p[k]));
            } else {
                setVal('precip_mode', 'single');
                $('precip_mode').dispatchEvent(new Event('change'));
                if (keys.length > 0) {
                    setVal('precip_type', keys[0]);
                    setVal('precip_density', p[keys[0]]);
                }
            }
        } else toggleComp('comp_precip', false);

        // --- Ambient Sounds ---
        if (comps['minecraft:ambient_sounds']) {
            toggleComp('comp_ambient', true);
            const as = comps['minecraft:ambient_sounds'];
            setVal('ambient_loop', as.loop);
            setVal('ambient_mood', as.mood);
            if (as.addition) {
                setVal('ambient_add_asset', as.addition.asset);
                setVal('ambient_add_chance', as.addition.chance);
            }
            
            // Underwater
            if (as.underwater_loop || as.underwater_mood || as.underwater_addition) {
                toggleComp('comp_underwater_ambient', true);
                setVal('underwater_loop', as.underwater_loop);
                setVal('underwater_mood', as.underwater_mood);
                if (as.underwater_addition) {
                    setVal('underwater_add_asset', as.underwater_addition.asset);
                    setVal('underwater_add_chance', as.underwater_addition.chance);
                }
            } else {
                toggleComp('comp_underwater_ambient', false);
            }
        } else toggleComp('comp_ambient', false);

        // --- Music ---
        if (comps['minecraft:biome_music']) {
            toggleComp('comp_music', true);
            const bm = comps['minecraft:biome_music'];
            setVal('music_definition', bm.music_definition);
            setVal('music_volume', bm.volume_multiplier);
            if (bm.underwater_music !== undefined) {
                setVal('music_underwater', bm.underwater_music.toString());
            }
        } else toggleComp('comp_music', false);

        alert("Client Biome imported successfully!");

    } catch (e) {
        alert("Error importing Client JSON: " + e.message);
        console.error(e);
    }
}

// --- Download .mcaddon Event Listener ---
document.getElementById('downloadMcaddonButton').addEventListener('click', async () => {
    // 1. Gather Data
    const serverJsonText = document.getElementById('jsonOutput').textContent;
    const clientJsonText = document.getElementById('outputJson').textContent; // Note: Uses textContent now
    const identifier = document.getElementById('identifier').value.trim().toLowerCase();

    // 2. Validation
    if (!serverJsonText || !clientJsonText) {
        alert("Please generate BOTH the Server Biome and Client Biome first.");
        return;
    }
    if (!identifier || !/^[a-z0-9._%+\-]+:[a-z0-9._%+\-]+$/.test(identifier)) {
        alert("Invalid Identifier. Please ensure it matches namespace:name pattern.");
        return;
    }

    // 3. Parse Data
    let serverData, clientData;
    try {
        serverData = JSON.parse(serverJsonText);
        clientData = JSON.parse(clientJsonText);
    } catch (e) {
        alert("Error parsing JSON data. Please regenerate.");
        return;
    }

    // 4. Prepare File Names & IDs
    const namePart = identifier.split(':')[1];
    const cleanName = namePart.replace(/[^a-z0-9._-]/g, '_');
    const packName = `BiBuild_${cleanName}`;
    
    // Generate UUIDs for linking
    const bpHeaderUuid = generateUuidv4();
    const bpModuleUuid = generateUuidv4();
    const rpHeaderUuid = generateUuidv4();
    const rpModuleUuid = generateUuidv4();

    const zip = new JSZip();

    // 5. Create Behavior Pack (BP) Structure
    const bpFolder = zip.folder(packName + "_BP");
    
    const bpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} BP`,
            "description": "Behavior Pack generated by Wanxian",
            "uuid": bpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 0]
        },
        "modules": [{ "type": "data", "uuid": bpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": rpHeaderUuid, "version": [1, 0, 0] }] // Dependency on RP
    };

    bpFolder.file("manifest.json", JSON.stringify(bpManifest, null, 2));
    // Add Biome File
    const bpBiomesFolder = bpFolder.folder("biomes");
    bpBiomesFolder.file(`${cleanName}.biome.json`, serverJsonText);

    // 6. Create Resource Pack (RP) Structure
    const rpFolder = zip.folder(packName + "_RP");

    const rpManifest = {
        "format_version": 2,
        "header": {
            "name": `${packName} RP`,
            "description": "Resource Pack generated by Wanxian",
            "uuid": rpHeaderUuid,
            "version": [1, 0, 0],
            "min_engine_version": [1, 21, 0]
        },
        "modules": [{ "type": "resources", "uuid": rpModuleUuid, "version": [1, 0, 0] }],
        "dependencies": [{ "uuid": bpHeaderUuid, "version": [1, 0, 0] }] // Dependency on BP
    };

    rpFolder.file("manifest.json", JSON.stringify(rpManifest, null, 2));
    // Add Client Biome File
    const rpBiomesFolder = rpFolder.folder("biomes");
    rpBiomesFolder.file(`${cleanName}.client_biome.json`, clientJsonText);

    // 7. Add Icons (Fetch placeholder)
    try {
        const response = await fetch('/icons/icon3.png');
        if (response.ok) {
            const blob = await response.blob();
            bpFolder.file("pack_icon.png", blob);
            rpFolder.file("pack_icon.png", blob);
        }
    } catch (e) {
        console.warn("Could not fetch pack icon.", e);
    }

    // 8. Export
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(content);
        a.download = `${packName}.mcaddon`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showSnackbar("Successfully exported .mcaddon!");
    } catch (error) {
        alert(`Failed to create .mcaddon: ${error.message}`);
    }
});

</script>

<script>
    /**
 * M3 Expressive Multi-Select Initializer
 * Automatically converts existing <select multiple> elements into M3 UI.
 */
function initMultiSelects() {
    const selects = document.querySelectorAll('select[multiple]');

    selects.forEach(select => {
        // Check if already processed
        if (select.dataset.m3Initialized) return;
        select.dataset.m3Initialized = "true";

        // Hide native select
        select.style.display = 'none';

        // Create Trigger UI
        const trigger = document.createElement('div');
        trigger.className = 'm3-select-trigger';
        
        const textSpan = document.createElement('span');
        textSpan.className = 'selection-text placeholder';
        textSpan.textContent = 'Select options...';
        
        const icon = document.createElement('span');
        icon.className = 'material-symbols-rounded';
        icon.textContent = '';
        icon.style.color = 'var(--md-sys-color-primary)';

        trigger.appendChild(textSpan);
        trigger.appendChild(icon);
        select.parentNode.insertBefore(trigger, select.nextSibling);

        // Initialize Trigger Text based on current selection
        updateTriggerText(select, textSpan);

        // Create Modal DOM (One per select for simplicity in state management)
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'm3-select-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'm3-select-modal';

        // Modal Header
        const header = document.createElement('div');
        header.className = 'm3-modal-header';
        header.innerHTML = `
            <h3>Select</h3>
            <span class="material-symbols-rounded" style="color: var(--md-sys-color-primary)">check_circle</span>
        `;

        // Modal Controls (Search + Select All)
        const controls = document.createElement('div');
        controls.className = 'm3-modal-controls';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.className = 'm3-search-input';
        searchInput.placeholder = 'Search options...';

        const toggleAllBtn = document.createElement('button');
        toggleAllBtn.type = 'button';
        toggleAllBtn.className = 'm3-toggle-all-btn';
        toggleAllBtn.title = "Select All / Deselect All";
        toggleAllBtn.innerHTML = '<span class="material-symbols-rounded">select_all</span>';

        controls.appendChild(searchInput);
        controls.appendChild(toggleAllBtn);

        // List Container
        const listContainer = document.createElement('div');
        listContainer.className = 'm3-modal-list';

        // Modal Footer
        const footer = document.createElement('div');
        footer.className = 'm3-modal-footer';
        
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'm3-modal-btn m3-btn-text';
        cancelBtn.textContent = 'Cancel';

        const okBtn = document.createElement('button');
        okBtn.type = 'button';
        okBtn.className = 'm3-modal-btn m3-btn-filled';
        okBtn.textContent = 'Okay';

        footer.appendChild(cancelBtn);
        footer.appendChild(okBtn);

        // Assemble Modal
        modal.appendChild(header);
        modal.appendChild(controls);
        modal.appendChild(listContainer);
        modal.appendChild(footer);
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);

        // State Variables
        let tempSelectedValues = new Set();

        // --- Event Listeners ---

        // Open Modal
        trigger.addEventListener('click', () => {
            // 1. Reset Temp State from Native Select
            tempSelectedValues.clear();
            Array.from(select.options).forEach(opt => {
                if (opt.selected) tempSelectedValues.add(opt.value);
            });

            // 2. Populate List
            renderList();
            
            // 3. Clear Search
            searchInput.value = '';
            filterList('');

            // 4. Show
            trigger.classList.add('active');
            modalOverlay.classList.add('open');
        });

        // Render List Function
        function renderList() {
            listContainer.innerHTML = '';
            Array.from(select.options).forEach(opt => {
                const item = document.createElement('div');
                item.className = 'm3-option-item';
                if (tempSelectedValues.has(opt.value)) item.classList.add('selected');
                
                item.dataset.value = opt.value;
                item.dataset.label = opt.text.toLowerCase(); // For search

                const checkbox = document.createElement('div');
                checkbox.className = 'm3-option-checkbox';
                
                const label = document.createElement('span');
                label.className = 'm3-option-label';
                label.textContent = opt.text;

                item.appendChild(checkbox);
                item.appendChild(label);
                listContainer.appendChild(item);

                // Toggle Item Click
                item.addEventListener('click', () => {
                    if (tempSelectedValues.has(opt.value)) {
                        tempSelectedValues.delete(opt.value);
                        item.classList.remove('selected');
                    } else {
                        tempSelectedValues.add(opt.value);
                        item.classList.add('selected');
                    }
                });
            });
        }

        // Search Function
        searchInput.addEventListener('input', (e) => {
            filterList(e.target.value.toLowerCase());
        });

        function filterList(query) {
            const items = listContainer.querySelectorAll('.m3-option-item');
            items.forEach(item => {
                const text = item.dataset.label;
                if (text.includes(query)) {
                    item.classList.remove('hidden');
                } else {
                    item.classList.add('hidden');
                }
            });
        }

        // Toggle All
        toggleAllBtn.addEventListener('click', () => {
            const visibleItems = Array.from(listContainer.querySelectorAll('.m3-option-item:not(.hidden)'));
            const allVisibleSelected = visibleItems.every(item => tempSelectedValues.has(item.dataset.value));

            if (allVisibleSelected) {
                // Deselect all visible
                visibleItems.forEach(item => {
                    tempSelectedValues.delete(item.dataset.value);
                    item.classList.remove('selected');
                });
            } else {
                // Select all visible
                visibleItems.forEach(item => {
                    tempSelectedValues.add(item.dataset.value);
                    item.classList.add('selected');
                });
            }
        });

        // Cancel
        cancelBtn.addEventListener('click', () => {
            modalOverlay.classList.remove('open');
            trigger.classList.remove('active');
        });

        // Okay (Save)
        okBtn.addEventListener('click', () => {
            // Apply to Native Select
            Array.from(select.options).forEach(opt => {
                opt.selected = tempSelectedValues.has(opt.value);
            });

            // Trigger Change Event (for listeners)
            select.dispatchEvent(new Event('change'));

            // Update UI Text
            updateTriggerText(select, textSpan);

            // Close
            modalOverlay.classList.remove('open');
            trigger.classList.remove('active');
        });

        // Close on Overlay Click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.classList.remove('open');
                trigger.classList.remove('active');
            }
        });
    });
}

// Helper to update the trigger text
function updateTriggerText(select, textSpan) {
    const selectedOptions = Array.from(select.selectedOptions);
    const count = selectedOptions.length;

    if (count === 0) {
        textSpan.textContent = 'Select options...';
        textSpan.classList.add('placeholder');
    } else if (count === 1) {
        textSpan.textContent = selectedOptions[0].text;
        textSpan.classList.remove('placeholder');
    } else {
        textSpan.textContent = `${count} items selected`;
        textSpan.classList.remove('placeholder');
    }
}

// Initialize on Load
document.addEventListener('DOMContentLoaded', initMultiSelects);

// Optional: Watch for dynamic form resets to clear UI
document.addEventListener('reset', (e) => {
    setTimeout(() => { // Wait for native reset to finish
        const selects = document.querySelectorAll('select[multiple]');
        selects.forEach(select => {
             if(select.nextSibling && select.nextSibling.classList && select.nextSibling.classList.contains('m3-select-trigger')) {
                 const textSpan = select.nextSibling.querySelector('.selection-text');
                 updateTriggerText(select, textSpan);
             }
        });
    }, 0);
});

</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
    const track = document.getElementById('fastScrollTrack');
    const thumb = document.getElementById('fastScrollThumb');
    
    let isDragging = false;
    let hideTimeout;
    let startY;
    let startTop;

    // Configuration
    const HEADER_OFFSET = 70; // Matches CSS top
    const BOTTOM_OFFSET = 10; // Matches CSS bottom
    
    // --- 1. Update Thumb Position on Page Scroll ---
    window.addEventListener('scroll', () => {
        if (isDragging) return; // Don't update if user is holding it

        // Show scrollbar
        track.classList.add('visible');
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
            if (!track.matches(':hover') && !isDragging) {
                track.classList.remove('visible');
            }
        }, 1500); // Hide after 1.5s of inactivity

        updateThumbPosition();
    });

    function updateThumbPosition() {
        const windowHeight = window.innerHeight;
        const docHeight = document.body.scrollHeight;
        const trackHeight = windowHeight - HEADER_OFFSET - BOTTOM_OFFSET;
        const thumbHeight = thumb.offsetHeight;
        
        const scrollPercent = window.scrollY / (docHeight - windowHeight);
        
        // Calculate top position limited by track bounds
        const topPos = scrollPercent * (trackHeight - thumbHeight);
        
        thumb.style.top = `${Math.max(0, Math.min(topPos, trackHeight - thumbHeight))}px`;
    }

    // --- 2. Handle Dragging Logic ---

    function startDrag(e) {
        e.preventDefault();
        isDragging = true;
        thumb.classList.add('dragging');
        track.classList.add('visible');
        
        // Get initial Y position (Mouse or Touch)
        startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        startTop = parseFloat(thumb.style.top || 0);
        
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchend', stopDrag);
    }

    function onDrag(e) {
        if (!isDragging) return;
        e.preventDefault(); // Prevent text selection/native scroll

        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        const deltaY = clientY - startY;
        let newTop = startTop + deltaY;

        // Metrics
        const windowHeight = window.innerHeight;
        const docHeight = document.body.scrollHeight;
        const trackHeight = windowHeight - HEADER_OFFSET - BOTTOM_OFFSET;
        const thumbHeight = thumb.offsetHeight;
        const maxTop = trackHeight - thumbHeight;

        // Clamp values
        if (newTop < 0) newTop = 0;
        if (newTop > maxTop) newTop = maxTop;

        // Move Thumb visually immediately
        thumb.style.top = `${newTop}px`;

        // Scroll Page
        const scrollPercent = newTop / maxTop;
        const scrollToY = scrollPercent * (docHeight - windowHeight);
        
        window.scrollTo(0, scrollToY);
    }

    function stopDrag() {
        isDragging = false;
        thumb.classList.remove('dragging');
        
        // Cleanup listeners
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchend', stopDrag);
        
        // Start hide timer
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
            if (!track.matches(':hover')) {
                track.classList.remove('visible');
            }
        }, 1000);
    }

    // Attach Listeners
    thumb.addEventListener('mousedown', startDrag);
    thumb.addEventListener('touchstart', startDrag, { passive: false });
    
    // Initial Position
    updateThumbPosition();
    
    // Resize Observer to adjust if window size changes
    window.addEventListener('resize', updateThumbPosition);
});

</script>

<script>
/* --- Theme Management System (Loads from themes.js) --- */

function getThemePalettes() {
    // Check if external file loaded
    if (window.THEME_PALETTES) {
        return window.THEME_PALETTES;
    }
    console.warn("themes.js not loaded. Theme picker will be empty.");
    return {};
}

// 1. Logic to Apply Theme
function applyThemePalette(themeKey) {
    const palettes = getThemePalettes();
    const theme = palettes[themeKey];
    if (!theme) return;

    let styleTag = document.getElementById('dynamic-theme-styles');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'dynamic-theme-styles';
        document.head.appendChild(styleTag);
    }

    // Convert object to CSS string
    const rulesToCss = (rules) => Object.entries(rules).map(([k, v]) => `${k}: ${v};`).join(' ');

    styleTag.textContent = `
        :root {
            ${rulesToCss(theme.light)}
        }
        .dark-theme {
            ${rulesToCss(theme.dark)}
        }
    `;

    // Save to storage
    localStorage.setItem('selectedThemeKey', themeKey);
    
    // Update Active UI State
    document.querySelectorAll('.theme-option').forEach(el => {
        if (el.dataset.theme === themeKey) el.classList.add('active');
        else el.classList.remove('active');
    });
}

// 2. Render Theme UI
function initThemePicker() {
    const container = document.getElementById('themeListContainer');
    if (!container) return; // Guard clause
    
    container.innerHTML = '';
    const palettes = getThemePalettes();

    Object.keys(palettes).forEach(key => {
        const t = palettes[key];
        
        const card = document.createElement('div');
        card.className = 'theme-option';
        card.dataset.theme = key;
        
        // CSS vars for this specific preview circle
        card.style.setProperty('--preview-primary', t.preview.primary);
        card.style.setProperty('--preview-secondary', t.preview.secondary);
        card.style.setProperty('--preview-tertiary', t.preview.tertiary);
        card.style.setProperty('--preview-surface', t.preview.surface);

        card.innerHTML = `
            <div class="theme-preview-circle"></div>
            <div class="theme-label">${t.name}</div>
        `;

        card.addEventListener('click', () => {
            applyThemePalette(key);
        });

        container.appendChild(card);
    });

    // Load saved theme
    const saved = localStorage.getItem('selectedThemeKey') || 'default';
    if(palettes[saved]) {
        applyThemePalette(saved);
    } else {
        applyThemePalette('default');
    }
}

// 3. Initialize Listeners
document.addEventListener('DOMContentLoaded', () => {
    initThemePicker();

    // Theme Modal Toggles
    const themeBtn = document.getElementById('theme-button');
    const themeModal = document.getElementById('themeModalOverlay');
    const themeClose = document.getElementById('closeThemeModal');

    if(themeBtn && themeModal && themeClose) {
        themeBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation(); 
            const dropdown = document.getElementById('dropdown-menu');
            if(dropdown) dropdown.classList.remove('visible');
            themeModal.style.display = 'flex';
        });

        themeClose.addEventListener('click', () => {
            themeModal.style.display = 'none';
        });

        themeModal.addEventListener('click', (e) => {
            if (e.target === themeModal) themeModal.style.display = 'none';
        });
    }
});


</script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const unusedToggle = document.getElementById('show_unused_components');
        const unusedWrapper = document.getElementById('unused_components_wrapper');

        if (unusedToggle && unusedWrapper) {
            unusedToggle.addEventListener('change', () => {
                unusedWrapper.style.display = unusedToggle.checked ? 'block' : 'none';
            });
        }
    });
</script>

	</body>
</html>
